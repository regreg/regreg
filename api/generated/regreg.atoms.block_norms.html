

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>RegReg &mdash; RegReg Docuentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="atoms.cones" href="regreg.atoms.cones.html" />
    <link rel="prev" title="atoms" href="regreg.atoms.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience, time
				 series">

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/templogo2.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                v0.1.3+9.g60e3aef
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../agenda.html">RegReg development</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../documentation.html">RegReg documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../download.html">Downloading and installing RegReg</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../algorithms.html">RegReg algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../license.html">RegReg License Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../docattribute.html">RegReg documentation attribution</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.html">affine</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.factored_matrix.html">affine.factored_matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.fused_lasso.html">affine.fused_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.image2d.html">affine.image2d</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.multiscale.html">affine.multiscale</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.algorithms.html">algorithms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.html">atoms</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">atoms.block_norms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-atoms-block-norms">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">atoms.block_norms</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#classes">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.cones.html">atoms.cones</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.group_lasso.html">atoms.group_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.linear_constraints.html">atoms.linear_constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.mixed_lasso.html">atoms.mixed_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.seminorms.html">atoms.seminorms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.slope.html">atoms.slope</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.sparse_group_lasso.html">atoms.sparse_group_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.svd_norms.html">atoms.svd_norms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.weighted_atoms.html">atoms.weighted_atoms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.doctemplates.html">doctemplates</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.identity_quadratic.html">identity_quadratic</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.objdoctemplates.html">objdoctemplates</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.paths.html">paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.admm.html">problems.admm</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.composite.html">problems.composite</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.conjugate.html">problems.conjugate</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.container.html">problems.container</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.dual_problem.html">problems.dual_problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.separable.html">problems.separable</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.simple.html">problems.simple</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.html">smooth</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.glm.html">smooth.glm</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.losses.html">smooth.losses</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.quadratic.html">smooth.quadratic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Some examples illustrating basic objects in RegReg</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../documentation.html">RegReg documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../download.html">Downloading and installing RegReg</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../algorithms.html">RegReg algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../license.html">RegReg License Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../docattribute.html">RegReg documentation attribution</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.html">affine</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.factored_matrix.html">affine.factored_matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.fused_lasso.html">affine.fused_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.image2d.html">affine.image2d</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.multiscale.html">affine.multiscale</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.algorithms.html">algorithms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.html">atoms</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">atoms.block_norms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-atoms-block-norms">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">atoms.block_norms</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#classes">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.cones.html">atoms.cones</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.group_lasso.html">atoms.group_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.linear_constraints.html">atoms.linear_constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.mixed_lasso.html">atoms.mixed_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.seminorms.html">atoms.seminorms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.slope.html">atoms.slope</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.sparse_group_lasso.html">atoms.sparse_group_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.svd_norms.html">atoms.svd_norms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.weighted_atoms.html">atoms.weighted_atoms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.doctemplates.html">doctemplates</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.identity_quadratic.html">identity_quadratic</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.objdoctemplates.html">objdoctemplates</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.paths.html">paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.admm.html">problems.admm</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.composite.html">problems.composite</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.conjugate.html">problems.conjugate</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.container.html">problems.container</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.dual_problem.html">problems.dual_problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.separable.html">problems.separable</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.simple.html">problems.simple</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.html">smooth</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.glm.html">smooth.glm</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.losses.html">smooth.losses</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.quadratic.html">smooth.quadratic</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">regreg</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../documentation.html">RegReg documentation</a> &raquo;</li>
        
          <li><a href="../index.html">API</a> &raquo;</li>
        
      <li>RegReg</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/api/generated/regreg.atoms.block_norms.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="atoms-block-norms">
<h1>atoms.block_norms<a class="headerlink" href="#atoms-block-norms" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-atoms-block-norms">
<h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">atoms.block_norms</span></code><a class="headerlink" href="#module-atoms-block-norms" title="Permalink to this headline">¶</a></h2>
<p>Inheritance diagram for <code class="docutils literal notranslate"><span class="pre">regreg.atoms.block_norms</span></code>:</p>
digraph inheritance029ba6e895 {
rankdir=LR;
size=&quot;8.0, 12.0&quot;;
  &quot;atoms.block_norms.block_max&quot; [URL=&quot;#regreg.atoms.block_norms.block_max&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;];
  &quot;atoms.block_norms.block_sum&quot; -&gt; &quot;atoms.block_norms.block_max&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;atoms.block_norms.block_sum&quot; [URL=&quot;#regreg.atoms.block_norms.block_sum&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;];
  &quot;atoms.seminorms.seminorm&quot; -&gt; &quot;atoms.block_norms.block_sum&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;atoms.block_norms.l1_l1&quot; [URL=&quot;#regreg.atoms.block_norms.l1_l1&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;];
  &quot;atoms.block_norms.l1_l2&quot; -&gt; &quot;atoms.block_norms.l1_l1&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;atoms.block_norms.l1_l2&quot; [URL=&quot;#regreg.atoms.block_norms.l1_l2&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;];
  &quot;atoms.block_norms.block_sum&quot; -&gt; &quot;atoms.block_norms.l1_l2&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;atoms.block_norms.linf_l2&quot; [URL=&quot;#regreg.atoms.block_norms.linf_l2&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;];
  &quot;atoms.block_norms.block_max&quot; -&gt; &quot;atoms.block_norms.linf_l2&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;atoms.block_norms.linf_linf&quot; [URL=&quot;#regreg.atoms.block_norms.linf_linf&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;];
  &quot;atoms.block_norms.linf_l2&quot; -&gt; &quot;atoms.block_norms.linf_linf&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;atoms.seminorms.seminorm&quot; [URL=&quot;regreg.atoms.seminorms.html#regreg.atoms.seminorms.seminorm&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;An atom that can be in lagrange or bound form.&quot;];
  &quot;regreg.atoms.atom&quot; -&gt; &quot;atoms.seminorms.seminorm&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;problems.composite.composite&quot; [URL=&quot;regreg.problems.composite.html#regreg.problems.composite.composite&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;A generic way to specify a problem in composite form.&quot;];
  &quot;problems.composite.nonsmooth&quot; [URL=&quot;regreg.problems.composite.html#regreg.problems.composite.nonsmooth&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;A composite subclass that explicitly returns 0&quot;];
  &quot;problems.composite.composite&quot; -&gt; &quot;problems.composite.nonsmooth&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;regreg.atoms.atom&quot; [URL=&quot;regreg.atoms.html#regreg.atoms.atom&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;A class that defines the API for support functions.&quot;];
  &quot;problems.composite.nonsmooth&quot; -&gt; &quot;regreg.atoms.atom&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
}
<span class="target" id="module-regreg.atoms.block_norms"></span><p>This module contains the implementation of block norms, i.e.
l1/l*, linf/l* norms. These are used in multiresponse LASSOs.</p>
</div>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="block-max">
<h3><a class="reference internal" href="#regreg.atoms.block_norms.block_max" title="regreg.atoms.block_norms.block_max"><code class="xref py py-class docutils literal notranslate"><span class="pre">block_max</span></code></a><a class="headerlink" href="#block-max" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="regreg.atoms.block_norms.block_max">
<em class="property">class </em><code class="sig-prename descclassname">regreg.atoms.block_norms.</code><code class="sig-name descname">block_max</code><span class="sig-paren">(</span><em class="sig-param">atom_cls</em>, <em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#regreg.atoms.block_norms.block_sum" title="regreg.atoms.block_norms.block_sum"><code class="xref py py-class docutils literal notranslate"><span class="pre">regreg.atoms.block_norms.block_sum</span></code></a></p>
<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">atom_cls</em>, <em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.affine">
<em class="property">classmethod </em><code class="sig-name descname">affine</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the same as the linear class method but with offset as a positional argument</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.apply_offset">
<code class="sig-name descname">apply_offset</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.apply_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>If self.offset is not None, return x-self.offset, else return x.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.bound">
<em class="property">property </em><code class="sig-name descname">bound</code><a class="headerlink" href="#regreg.atoms.block_norms.block_max.bound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.bound_prox">
<code class="sig-name descname">bound_prox</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">bound=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.bound_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\delta}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{n \times p}} 
\frac{1}{2}
\|\theta-B\|^2_2  \ 
\text{s.t.} \   \|B\|_{\infty,\| \cdot\|} \leq \delta\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta\)</span> is the bound parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>bound</cite> is None and the atom is in bound mode,
<code class="docutils literal notranslate"><span class="pre">self.bound</span></code> is used as the bound parameter, else an exception is
raised.</p>
<p>The class atom’s bound_prox just returns the appropriate bound
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>bound</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Bound for the constraint on the seminorm.
Defaults to <cite>self.bound</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.check_subgradient">
<em class="property">static </em><code class="sig-name descname">check_subgradient</code><span class="sig-paren">(</span><em class="sig-param">atom</em>, <em class="sig-param">prox_center</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.check_subgradient" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given seminorm, verify the KKT condition for
the problem for the proximal problem</p>
<div class="math notranslate nohighlight">
\[\text{minimize}_u \frac{1}{2} \|u-z\|^2_2 + h(z)\]</div>
<p>where <span class="math notranslate nohighlight">\(z\)</span> is the <cite>prox_center</cite> and <span class="math notranslate nohighlight">\(h\)</span> is <cite>atom</cite>
which may be in Lagrange or bound form.</p>
<p>If the atom is in Lagrange form, this function should
return two values equal to the seminorm of the 
minimizer. If it is bound form it should return two values
equal to the dual seminorm of the residual, i.e.
the prox_center minus the minimizer.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>atom</strong> : <cite>seminorm</cite></p>
<p><strong>prox_center</strong> : np.ndarray(np.float)</p>
<blockquote>
<div><p>Center for the proximal map.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>v1, v2</strong> : float</p>
<blockquote>
<div><p>Two values that should be equal if the proximal map is correct.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.conjugate">
<em class="property">property </em><code class="sig-name descname">conjugate</code><a class="headerlink" href="#regreg.atoms.block_norms.block_max.conjugate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.constraint">
<code class="sig-name descname">constraint</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">bound=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify <span class="math notranslate nohighlight">\(\|B\|_{\infty,\| \cdot\|} \leq \delta\)</span>, where <span class="math notranslate nohighlight">\(\delta\)</span>
is <cite>bound</cite>.</p>
<p>If the result is <cite>True</cite>, returns 0, else returns <cite>np.inf</cite>.</p>
<p>The class seminorm’s constraint just returns the appropriate bound
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.dual">
<em class="property">property </em><code class="sig-name descname">dual</code><a class="headerlink" href="#regreg.atoms.block_norms.block_max.dual" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.get_bound">
<code class="sig-name descname">get_bound</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.get_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_max</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.get_conjugate">
<code class="sig-name descname">get_conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.get_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the conjugate of an given atom.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_max</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">get_conjugate</span><span class="p">()</span> 
<span class="go">block_sum(..., bound=3.4...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.get_dual">
<code class="sig-name descname">get_dual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.get_dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual of an atom. This dual is formed by making introducing
new variables <span class="math notranslate nohighlight">\(v=Ax\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is <cite>self.linear_transform</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_max</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> 
<span class="go">block_max(..., lagrange=2.3...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.identity object at 0x...&gt;, block_sum(..., bound=2.3...))</span>
</pre></div>
</div>
<p>If there is a linear part to the penalty, the linear_transform may not be 
identity. For example, the 1D fused LASSO penalty:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="mi">1</span><span class="p">))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span>
<span class="go">array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> 
<span class="go">affine_atom(l1norm((3,), lagrange=2.3...), array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.linear_transform object at 0x...&gt;, supnorm((3,), bound=2.3...))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.get_lagrange">
<code class="sig-name descname">get_lagrange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.get_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_max</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.get_offset">
<code class="sig-name descname">get_offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.get_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.get_quadratic">
<code class="sig-name descname">get_quadratic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.get_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.lagrange">
<em class="property">property </em><code class="sig-name descname">lagrange</code><a class="headerlink" href="#regreg.atoms.block_norms.block_max.lagrange" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.lagrange_prox">
<code class="sig-name descname">lagrange_prox</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">lipschitz=1</em>, <em class="sig-param">lagrange=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.lagrange_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\lambda}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{n \times p}} 
\frac{L}{2}
\|\theta-B\|^2_2 + \lambda \|B\|_{\infty,\| \cdot\|} \]</div>
<p>Above, <span class="math notranslate nohighlight">\(\lambda\)</span> is the Lagrange parameter and <span class="math notranslate nohighlight">\(L\)</span>
is the Lipschitz parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>lagrange</cite> is None and the atom is in lagrange mode,
<code class="docutils literal notranslate"><span class="pre">self.lagrange</span></code> is used as the lagrange parameter, else an exception
is raised.</p>
<p>The class atom’s lagrange_prox just returns the appropriate lagrange
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>lipschitz</strong> : <cite>float</cite></p>
<blockquote>
<div><p>Coefficient in front of the quadratic.</p>
</div></blockquote>
<p><strong>lagrange</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Lagrange factor in front of the seminorm. 
Defaults to <cite>self.lagrange</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.latexify">
<code class="sig-name descname">latexify</code><span class="sig-paren">(</span><em class="sig-param">var=None</em>, <em class="sig-param">idx=''</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.latexify" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a LaTeX representation of an object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">latexify</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\gamma&#39;</span><span class="p">)</span> 
<span class="go">&#39;\\lambda_{} \\|\\gamma\\|_1&#39;</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>var</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Argument of the functions</p>
</div></blockquote>
<p><strong>idx</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Optional subscript index.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>L</strong> : <cite>string</cite></p>
<blockquote>
<div><p>A LaTeX representation of the atom.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.linear">
<em class="property">classmethod </em><code class="sig-name descname">linear</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">offset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.linear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.linear_transform">
<em class="property">property </em><code class="sig-name descname">linear_transform</code><a class="headerlink" href="#regreg.atoms.block_norms.block_max.linear_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The linear transform applied before a penalty is computed. Defaults to regreg.affine.identity</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">regreg.api</span> <span class="k">import</span> <span class="n">l1norm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">l1norm</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">penalty</span><span class="o">.</span><span class="n">linear_transform</span><span class="p">)</span>
<span class="go">&lt;class &#39;regreg.affine.identity&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.nonsmooth_objective">
<code class="sig-name descname">nonsmooth_objective</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.nonsmooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The nonsmooth objective function of the atom.
Includes <cite>self.quadratic.objective(arg)</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">nonsmooth_objective</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the seminorm.</p>
</div></blockquote>
<p><strong>check_feasibility</strong> : <cite>bool</cite></p>
<blockquote>
<div><p>If <cite>True</cite>, then return <cite>np.inf</cite> if appropriate.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> : <cite>np.float</cite></p>
<blockquote>
<div><p>The seminorm of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.objective">
<code class="sig-name descname">objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.objective" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.block_max.objective_template">
<code class="sig-name descname">objective_template</code><em class="property"> = '\\|%(var)s\\|_{\\infty,\\| \\cdot\\|}'</em><a class="headerlink" href="#regreg.atoms.block_norms.block_max.objective_template" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.block_max.objective_vars">
<code class="sig-name descname">objective_vars</code><em class="property"> = {'dualnormklass': 'block_sum', 'initargs': 'rr.l1norm, (5, 4)', 'linear': 'D', 'normklass': 'block_max', 'offset': '\\alpha', 'shape': 'n \\times p', 'var': 'B'}</em><a class="headerlink" href="#regreg.atoms.block_norms.block_max.objective_vars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.offset">
<em class="property">property </em><code class="sig-name descname">offset</code><a class="headerlink" href="#regreg.atoms.block_norms.block_max.offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>The proximal operator. If the atom is in
Lagrange mode, this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\lambda}(\theta) = \text{argmin}_{B \in
\mathbb{R}^{n \times p}} \frac{L}{2} \|\theta-B\|^2_2
+ \lambda h(B-\alpha) + \langle B, \eta \rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is <cite>self.offset</cite>,
<span class="math notranslate nohighlight">\(\eta\)</span> is <cite>quadratic.linear_term</cite>, <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>quadratic.center</cite> and</p>
<div class="math notranslate nohighlight">
\[h(B) = \|B\|_{\infty,\| \cdot\|}\]</div>
<p>If the atom is in bound mode, then this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\delta}(\theta) = \text{argmin}_{B \in \mathbb{R}^{n \times p}} \frac{L}{2}
\|\theta-B\|^2_2 + \langle B, \eta \rangle \  \text{s.t.} \   
h(B - \alpha) \leq \delta\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">identity_quadratic</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> 
<span class="go">array([ 1.6666..., -2.6666..., -0.        ,  0.        ])</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>quadratic</strong> : <cite>regreg.identity_quadratic.identity_quadratic</cite></p>
<blockquote>
<div><p>A quadratic added to the atom before minimizing.</p>
</div></blockquote>
<p><strong>prox_control</strong> : <cite>[None, dict]</cite></p>
<blockquote>
<div><p>This argument is ignored for seminorms, but otherwise
is passed to <cite>regreg.algorithms.FISTA</cite> if the atom
needs to be solved iteratively.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of the implied center of <cite>quadratic</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.proximal_optimum">
<code class="sig-name descname">proximal_optimum</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.proximal_optimum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.proximal_step">
<code class="sig-name descname">proximal_step</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.proximal_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the proximal optimization</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>prox_control: [None, dict]</strong></p>
<blockquote>
<div><p>If not None, then a dictionary of parameters for the prox procedure</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.quadratic">
<em class="property">property </em><code class="sig-name descname">quadratic</code><a class="headerlink" href="#regreg.atoms.block_norms.block_max.quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Quadratic part of the object, instance of <cite>regreg.identity_quadratic.identity_quadratic</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.seminorm">
<code class="sig-name descname">seminorm</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.seminorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math notranslate nohighlight">\(\lambda \cdot \|B\|_{\infty,\| \cdot\|}\)</span>, where
<span class="math notranslate nohighlight">\(\lambda\)</span> is <cite>lagrange</cite>. If <cite>check_feasibility</cite>
is <cite>True</cite>, and seminorm is unbounded, will return <cite>np.inf</cite>
if appropriate.</p>
<p>The class seminorm’s seminorm just returns the appropriate lagrange
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.seminorms">
<code class="sig-name descname">seminorms</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.seminorms" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all seminorms in the block norm.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.set_bound">
<code class="sig-name descname">set_bound</code><span class="sig-paren">(</span><em class="sig-param">bound</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.set_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_max</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_max</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in lagrange mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.set_lagrange">
<code class="sig-name descname">set_lagrange</code><span class="sig-paren">(</span><em class="sig-param">lagrange</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.set_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_max</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_max</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in bound mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.set_offset">
<code class="sig-name descname">set_offset</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.set_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.set_quadratic">
<code class="sig-name descname">set_quadratic</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.set_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.shift">
<em class="property">classmethod </em><code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.shift" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.smooth_objective">
<code class="sig-name descname">smooth_objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">mode='both'</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.smooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The zero function.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.smoothed">
<code class="sig-name descname">smoothed</code><span class="sig-paren">(</span><em class="sig-param">smoothing_quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.smoothed" title="Permalink to this definition">¶</a></dt>
<dd><p>Add quadratic smoothing term</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_max.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">quadratic=None</em>, <em class="sig-param">return_optimum=False</em>, <em class="sig-param">**fit_args</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_max.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.block_max.tol">
<code class="sig-name descname">tol</code><em class="property"> = 1e-05</em><a class="headerlink" href="#regreg.atoms.block_norms.block_max.tol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="block-sum">
<h3><a class="reference internal" href="#regreg.atoms.block_norms.block_sum" title="regreg.atoms.block_norms.block_sum"><code class="xref py py-class docutils literal notranslate"><span class="pre">block_sum</span></code></a><a class="headerlink" href="#block-sum" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="regreg.atoms.block_norms.block_sum">
<em class="property">class </em><code class="sig-prename descclassname">regreg.atoms.block_norms.</code><code class="sig-name descname">block_sum</code><span class="sig-paren">(</span><em class="sig-param">atom_cls</em>, <em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="regreg.atoms.seminorms.html#regreg.atoms.seminorms.seminorm" title="regreg.atoms.seminorms.seminorm"><code class="xref py py-class docutils literal notranslate"><span class="pre">regreg.atoms.seminorms.seminorm</span></code></a></p>
<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">atom_cls</em>, <em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.affine">
<em class="property">classmethod </em><code class="sig-name descname">affine</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the same as the linear class method but with offset as a positional argument</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.apply_offset">
<code class="sig-name descname">apply_offset</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.apply_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>If self.offset is not None, return x-self.offset, else return x.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.bound">
<em class="property">property </em><code class="sig-name descname">bound</code><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.bound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.bound_prox">
<code class="sig-name descname">bound_prox</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">bound=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.bound_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\delta}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{n \times p}} 
\frac{1}{2}
\|\theta-B\|^2_2  \ 
\text{s.t.} \   \|B\|_{1,\|\cdot\|} \leq \delta\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta\)</span> is the bound parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>bound</cite> is None and the atom is in bound mode,
<code class="docutils literal notranslate"><span class="pre">self.bound</span></code> is used as the bound parameter, else an exception is
raised.</p>
<p>The class atom’s bound_prox just returns the appropriate bound
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>bound</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Bound for the constraint on the seminorm.
Defaults to <cite>self.bound</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.check_subgradient">
<em class="property">static </em><code class="sig-name descname">check_subgradient</code><span class="sig-paren">(</span><em class="sig-param">atom</em>, <em class="sig-param">prox_center</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.check_subgradient" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given seminorm, verify the KKT condition for
the problem for the proximal problem</p>
<div class="math notranslate nohighlight">
\[\text{minimize}_u \frac{1}{2} \|u-z\|^2_2 + h(z)\]</div>
<p>where <span class="math notranslate nohighlight">\(z\)</span> is the <cite>prox_center</cite> and <span class="math notranslate nohighlight">\(h\)</span> is <cite>atom</cite>
which may be in Lagrange or bound form.</p>
<p>If the atom is in Lagrange form, this function should
return two values equal to the seminorm of the 
minimizer. If it is bound form it should return two values
equal to the dual seminorm of the residual, i.e.
the prox_center minus the minimizer.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>atom</strong> : <cite>seminorm</cite></p>
<p><strong>prox_center</strong> : np.ndarray(np.float)</p>
<blockquote>
<div><p>Center for the proximal map.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>v1, v2</strong> : float</p>
<blockquote>
<div><p>Two values that should be equal if the proximal map is correct.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.conjugate">
<em class="property">property </em><code class="sig-name descname">conjugate</code><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.conjugate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.constraint">
<code class="sig-name descname">constraint</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify <span class="math notranslate nohighlight">\(\|B\|_{1,\|\cdot\|} \leq \delta\)</span>, where <span class="math notranslate nohighlight">\(\delta\)</span>
is <cite>bound</cite>.</p>
<p>If the result is <cite>True</cite>, returns 0, else returns <cite>np.inf</cite>.</p>
<p>The class seminorm’s constraint just returns the appropriate bound
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.dual">
<em class="property">property </em><code class="sig-name descname">dual</code><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.dual" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.get_bound">
<code class="sig-name descname">get_bound</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.get_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_sum</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.get_conjugate">
<code class="sig-name descname">get_conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.get_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the conjugate of an given atom.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_sum</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">get_conjugate</span><span class="p">()</span> 
<span class="go">block_max(..., bound=3.4...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.get_dual">
<code class="sig-name descname">get_dual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.get_dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual of an atom. This dual is formed by making introducing
new variables <span class="math notranslate nohighlight">\(v=Ax\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is <cite>self.linear_transform</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_sum</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> 
<span class="go">block_sum(..., lagrange=2.3...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.identity object at 0x...&gt;, block_max(..., bound=2.3...))</span>
</pre></div>
</div>
<p>If there is a linear part to the penalty, the linear_transform may not be 
identity. For example, the 1D fused LASSO penalty:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="mi">1</span><span class="p">))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span>
<span class="go">array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> 
<span class="go">affine_atom(l1norm((3,), lagrange=2.3...), array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.linear_transform object at 0x...&gt;, supnorm((3,), bound=2.3...))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.get_lagrange">
<code class="sig-name descname">get_lagrange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.get_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_sum</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.get_offset">
<code class="sig-name descname">get_offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.get_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.get_quadratic">
<code class="sig-name descname">get_quadratic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.get_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.lagrange">
<em class="property">property </em><code class="sig-name descname">lagrange</code><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.lagrange" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.lagrange_prox">
<code class="sig-name descname">lagrange_prox</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">lipschitz=1</em>, <em class="sig-param">lagrange=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.lagrange_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\lambda}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{n \times p}} 
\frac{L}{2}
\|\theta-B\|^2_2 + \lambda \|B\|_{1,\|\cdot\|} \]</div>
<p>Above, <span class="math notranslate nohighlight">\(\lambda\)</span> is the Lagrange parameter and <span class="math notranslate nohighlight">\(L\)</span>
is the Lipschitz parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>lagrange</cite> is None and the atom is in lagrange mode,
<code class="docutils literal notranslate"><span class="pre">self.lagrange</span></code> is used as the lagrange parameter, else an exception
is raised.</p>
<p>The class atom’s lagrange_prox just returns the appropriate lagrange
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>lipschitz</strong> : <cite>float</cite></p>
<blockquote>
<div><p>Coefficient in front of the quadratic.</p>
</div></blockquote>
<p><strong>lagrange</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Lagrange factor in front of the seminorm. 
Defaults to <cite>self.lagrange</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.latexify">
<code class="sig-name descname">latexify</code><span class="sig-paren">(</span><em class="sig-param">var=None</em>, <em class="sig-param">idx=''</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.latexify" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a LaTeX representation of an object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">latexify</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\gamma&#39;</span><span class="p">)</span> 
<span class="go">&#39;\\lambda_{} \\|\\gamma\\|_1&#39;</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>var</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Argument of the functions</p>
</div></blockquote>
<p><strong>idx</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Optional subscript index.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>L</strong> : <cite>string</cite></p>
<blockquote>
<div><p>A LaTeX representation of the atom.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.linear">
<em class="property">classmethod </em><code class="sig-name descname">linear</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">offset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.linear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.linear_transform">
<em class="property">property </em><code class="sig-name descname">linear_transform</code><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.linear_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The linear transform applied before a penalty is computed. Defaults to regreg.affine.identity</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">regreg.api</span> <span class="k">import</span> <span class="n">l1norm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">l1norm</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">penalty</span><span class="o">.</span><span class="n">linear_transform</span><span class="p">)</span>
<span class="go">&lt;class &#39;regreg.affine.identity&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.nonsmooth_objective">
<code class="sig-name descname">nonsmooth_objective</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.nonsmooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The nonsmooth objective function of the atom.
Includes <cite>self.quadratic.objective(arg)</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">nonsmooth_objective</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the seminorm.</p>
</div></blockquote>
<p><strong>check_feasibility</strong> : <cite>bool</cite></p>
<blockquote>
<div><p>If <cite>True</cite>, then return <cite>np.inf</cite> if appropriate.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> : <cite>np.float</cite></p>
<blockquote>
<div><p>The seminorm of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.objective">
<code class="sig-name descname">objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.objective" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.block_sum.objective_template">
<code class="sig-name descname">objective_template</code><em class="property"> = '\\|%(var)s\\|_{1,\\|\\cdot\\|}'</em><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.objective_template" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.block_sum.objective_vars">
<code class="sig-name descname">objective_vars</code><em class="property"> = {'dualnormklass': 'block_max', 'initargs': 'rr.l1norm, (5, 4)', 'linear': 'D', 'normklass': 'block_sum', 'offset': '\\alpha', 'shape': 'n \\times p', 'var': 'B'}</em><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.objective_vars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.offset">
<em class="property">property </em><code class="sig-name descname">offset</code><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>The proximal operator. If the atom is in
Lagrange mode, this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\lambda}(\theta) = \text{argmin}_{B \in
\mathbb{R}^{n \times p}} \frac{L}{2} \|\theta-B\|^2_2
+ \lambda h(B-\alpha) + \langle B, \eta \rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is <cite>self.offset</cite>,
<span class="math notranslate nohighlight">\(\eta\)</span> is <cite>quadratic.linear_term</cite>, <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>quadratic.center</cite> and</p>
<div class="math notranslate nohighlight">
\[h(B) = \|B\|_{1,\|\cdot\|}\]</div>
<p>If the atom is in bound mode, then this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\delta}(\theta) = \text{argmin}_{B \in \mathbb{R}^{n \times p}} \frac{L}{2}
\|\theta-B\|^2_2 + \langle B, \eta \rangle \  \text{s.t.} \   
h(B - \alpha) \leq \delta\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">identity_quadratic</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> 
<span class="go">array([ 1.6666..., -2.6666..., -0.        ,  0.        ])</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>quadratic</strong> : <cite>regreg.identity_quadratic.identity_quadratic</cite></p>
<blockquote>
<div><p>A quadratic added to the atom before minimizing.</p>
</div></blockquote>
<p><strong>prox_control</strong> : <cite>[None, dict]</cite></p>
<blockquote>
<div><p>This argument is ignored for seminorms, but otherwise
is passed to <cite>regreg.algorithms.FISTA</cite> if the atom
needs to be solved iteratively.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of the implied center of <cite>quadratic</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.proximal_optimum">
<code class="sig-name descname">proximal_optimum</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.proximal_optimum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.proximal_step">
<code class="sig-name descname">proximal_step</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.proximal_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the proximal optimization</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>prox_control: [None, dict]</strong></p>
<blockquote>
<div><p>If not None, then a dictionary of parameters for the prox procedure</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.quadratic">
<em class="property">property </em><code class="sig-name descname">quadratic</code><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Quadratic part of the object, instance of <cite>regreg.identity_quadratic.identity_quadratic</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.seminorm">
<code class="sig-name descname">seminorm</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">check_feasibility=False</em>, <em class="sig-param">lagrange=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.seminorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math notranslate nohighlight">\(\lambda \cdot \|B\|_{1,\|\cdot\|}\)</span>, where
<span class="math notranslate nohighlight">\(\lambda\)</span> is <cite>lagrange</cite>. If <cite>check_feasibility</cite>
is <cite>True</cite>, and seminorm is unbounded, will return <cite>np.inf</cite>
if appropriate.</p>
<p>The class seminorm’s seminorm just returns the appropriate lagrange
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.seminorms">
<code class="sig-name descname">seminorms</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.seminorms" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all seminorms in the block norm.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.set_bound">
<code class="sig-name descname">set_bound</code><span class="sig-paren">(</span><em class="sig-param">bound</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.set_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_sum</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_sum</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in lagrange mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.set_lagrange">
<code class="sig-name descname">set_lagrange</code><span class="sig-paren">(</span><em class="sig-param">lagrange</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.set_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_sum</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">block_sum</span><span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in bound mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.set_offset">
<code class="sig-name descname">set_offset</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.set_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.set_quadratic">
<code class="sig-name descname">set_quadratic</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.set_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.shift">
<em class="property">classmethod </em><code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.shift" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.smooth_objective">
<code class="sig-name descname">smooth_objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">mode='both'</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.smooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The zero function.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.smoothed">
<code class="sig-name descname">smoothed</code><span class="sig-paren">(</span><em class="sig-param">smoothing_quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.smoothed" title="Permalink to this definition">¶</a></dt>
<dd><p>Add quadratic smoothing term</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.block_sum.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">quadratic=None</em>, <em class="sig-param">return_optimum=False</em>, <em class="sig-param">**fit_args</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.block_sum.tol">
<code class="sig-name descname">tol</code><em class="property"> = 1e-05</em><a class="headerlink" href="#regreg.atoms.block_norms.block_sum.tol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="l1-l1">
<h3><a class="reference internal" href="#regreg.atoms.block_norms.l1_l1" title="regreg.atoms.block_norms.l1_l1"><code class="xref py py-class docutils literal notranslate"><span class="pre">l1_l1</span></code></a><a class="headerlink" href="#l1-l1" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="regreg.atoms.block_norms.l1_l1">
<em class="property">class </em><code class="sig-prename descclassname">regreg.atoms.block_norms.</code><code class="sig-name descname">l1_l1</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#regreg.atoms.block_norms.l1_l2" title="regreg.atoms.block_norms.l1_l2"><code class="xref py py-class docutils literal notranslate"><span class="pre">regreg.atoms.block_norms.l1_l2</span></code></a></p>
<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.affine">
<em class="property">classmethod </em><code class="sig-name descname">affine</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the same as the linear class method but with offset as a positional argument</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.apply_offset">
<code class="sig-name descname">apply_offset</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.apply_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>If self.offset is not None, return x-self.offset, else return x.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.bound">
<em class="property">property </em><code class="sig-name descname">bound</code><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.bound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.bound_prox">
<code class="sig-name descname">bound_prox</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">bound=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.bound_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\delta}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{n \times p}} 
\frac{1}{2}
\|\theta-B\|^2_2  \ 
\text{s.t.} \   \|B\|_{1,1} \leq \delta\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta\)</span> is the bound parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>bound</cite> is None and the atom is in bound mode,
<code class="docutils literal notranslate"><span class="pre">self.bound</span></code> is used as the bound parameter, else an exception is
raised.</p>
<p>The class atom’s bound_prox just returns the appropriate bound
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>bound</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Bound for the constraint on the seminorm.
Defaults to <cite>self.bound</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.check_subgradient">
<em class="property">static </em><code class="sig-name descname">check_subgradient</code><span class="sig-paren">(</span><em class="sig-param">atom</em>, <em class="sig-param">prox_center</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.check_subgradient" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given seminorm, verify the KKT condition for
the problem for the proximal problem</p>
<div class="math notranslate nohighlight">
\[\text{minimize}_u \frac{1}{2} \|u-z\|^2_2 + h(z)\]</div>
<p>where <span class="math notranslate nohighlight">\(z\)</span> is the <cite>prox_center</cite> and <span class="math notranslate nohighlight">\(h\)</span> is <cite>atom</cite>
which may be in Lagrange or bound form.</p>
<p>If the atom is in Lagrange form, this function should
return two values equal to the seminorm of the 
minimizer. If it is bound form it should return two values
equal to the dual seminorm of the residual, i.e.
the prox_center minus the minimizer.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>atom</strong> : <cite>seminorm</cite></p>
<p><strong>prox_center</strong> : np.ndarray(np.float)</p>
<blockquote>
<div><p>Center for the proximal map.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>v1, v2</strong> : float</p>
<blockquote>
<div><p>Two values that should be equal if the proximal map is correct.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.conjugate">
<em class="property">property </em><code class="sig-name descname">conjugate</code><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.conjugate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.constraint">
<code class="sig-name descname">constraint</code><span class="sig-paren">(</span><em class="sig-param">arg</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify <span class="math notranslate nohighlight">\(\|B\|_{1,1} \leq \delta\)</span>, where <span class="math notranslate nohighlight">\(\delta\)</span>
is <cite>bound</cite>.</p>
<p>If the result is <cite>True</cite>, returns 0, else returns <cite>np.inf</cite>.</p>
<p>The class seminorm’s constraint just returns the appropriate bound
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.dual">
<em class="property">property </em><code class="sig-name descname">dual</code><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.dual" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.get_bound">
<code class="sig-name descname">get_bound</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.get_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l1</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.get_conjugate">
<code class="sig-name descname">get_conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.get_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the conjugate of an given atom.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l1</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">get_conjugate</span><span class="p">()</span> 
<span class="go">linf_linf(..., bound=3.4...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.get_dual">
<code class="sig-name descname">get_dual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.get_dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual of an atom. This dual is formed by making introducing
new variables <span class="math notranslate nohighlight">\(v=Ax\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is <cite>self.linear_transform</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l1</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> 
<span class="go">l1_l1(..., lagrange=2.3...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.identity object at 0x...&gt;, linf_linf(..., bound=2.3...))</span>
</pre></div>
</div>
<p>If there is a linear part to the penalty, the linear_transform may not be 
identity. For example, the 1D fused LASSO penalty:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="mi">1</span><span class="p">))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span>
<span class="go">array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> 
<span class="go">affine_atom(l1norm((3,), lagrange=2.3...), array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.linear_transform object at 0x...&gt;, supnorm((3,), bound=2.3...))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.get_lagrange">
<code class="sig-name descname">get_lagrange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.get_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l1</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.get_offset">
<code class="sig-name descname">get_offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.get_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.get_quadratic">
<code class="sig-name descname">get_quadratic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.get_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.lagrange">
<em class="property">property </em><code class="sig-name descname">lagrange</code><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.lagrange" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.lagrange_prox">
<code class="sig-name descname">lagrange_prox</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">lipschitz=1</em>, <em class="sig-param">lagrange=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.lagrange_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\lambda}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{n \times p}} 
\frac{L}{2}
\|\theta-B\|^2_2 + \lambda \|B\|_{1,1} \]</div>
<p>Above, <span class="math notranslate nohighlight">\(\lambda\)</span> is the Lagrange parameter and <span class="math notranslate nohighlight">\(L\)</span>
is the Lipschitz parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>lagrange</cite> is None and the atom is in lagrange mode,
<code class="docutils literal notranslate"><span class="pre">self.lagrange</span></code> is used as the lagrange parameter, else an exception
is raised.</p>
<p>The class atom’s lagrange_prox just returns the appropriate lagrange
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>lipschitz</strong> : <cite>float</cite></p>
<blockquote>
<div><p>Coefficient in front of the quadratic.</p>
</div></blockquote>
<p><strong>lagrange</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Lagrange factor in front of the seminorm. 
Defaults to <cite>self.lagrange</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.latexify">
<code class="sig-name descname">latexify</code><span class="sig-paren">(</span><em class="sig-param">var=None</em>, <em class="sig-param">idx=''</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.latexify" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a LaTeX representation of an object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">latexify</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\gamma&#39;</span><span class="p">)</span> 
<span class="go">&#39;\\lambda_{} \\|\\gamma\\|_1&#39;</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>var</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Argument of the functions</p>
</div></blockquote>
<p><strong>idx</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Optional subscript index.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>L</strong> : <cite>string</cite></p>
<blockquote>
<div><p>A LaTeX representation of the atom.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.linear">
<em class="property">classmethod </em><code class="sig-name descname">linear</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">offset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.linear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.linear_transform">
<em class="property">property </em><code class="sig-name descname">linear_transform</code><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.linear_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The linear transform applied before a penalty is computed. Defaults to regreg.affine.identity</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">regreg.api</span> <span class="k">import</span> <span class="n">l1norm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">l1norm</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">penalty</span><span class="o">.</span><span class="n">linear_transform</span><span class="p">)</span>
<span class="go">&lt;class &#39;regreg.affine.identity&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.nonsmooth_objective">
<code class="sig-name descname">nonsmooth_objective</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.nonsmooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The nonsmooth objective function of the atom.
Includes <cite>self.quadratic.objective(arg)</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">nonsmooth_objective</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the seminorm.</p>
</div></blockquote>
<p><strong>check_feasibility</strong> : <cite>bool</cite></p>
<blockquote>
<div><p>If <cite>True</cite>, then return <cite>np.inf</cite> if appropriate.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> : <cite>np.float</cite></p>
<blockquote>
<div><p>The seminorm of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.objective">
<code class="sig-name descname">objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.objective" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.l1_l1.objective_template">
<code class="sig-name descname">objective_template</code><em class="property"> = '\\|%(var)s\\|_{1,1}'</em><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.objective_template" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.l1_l1.objective_vars">
<code class="sig-name descname">objective_vars</code><em class="property"> = {'dualnormklass': 'linf_linf', 'initargs': '(5,4)', 'linear': 'D', 'normklass': 'l1_l1', 'offset': '\\alpha', 'shape': 'n \\times p', 'var': 'B'}</em><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.objective_vars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.offset">
<em class="property">property </em><code class="sig-name descname">offset</code><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>The proximal operator. If the atom is in
Lagrange mode, this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\lambda}(\theta) = \text{argmin}_{B \in
\mathbb{R}^{n \times p}} \frac{L}{2} \|\theta-B\|^2_2
+ \lambda h(B-\alpha) + \langle B, \eta \rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is <cite>self.offset</cite>,
<span class="math notranslate nohighlight">\(\eta\)</span> is <cite>quadratic.linear_term</cite>, <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>quadratic.center</cite> and</p>
<div class="math notranslate nohighlight">
\[h(B) = \|B\|_{1,1}\]</div>
<p>If the atom is in bound mode, then this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\delta}(\theta) = \text{argmin}_{B \in \mathbb{R}^{n \times p}} \frac{L}{2}
\|\theta-B\|^2_2 + \langle B, \eta \rangle \  \text{s.t.} \   
h(B - \alpha) \leq \delta\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">identity_quadratic</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> 
<span class="go">array([ 1.6666..., -2.6666..., -0.        ,  0.        ])</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>quadratic</strong> : <cite>regreg.identity_quadratic.identity_quadratic</cite></p>
<blockquote>
<div><p>A quadratic added to the atom before minimizing.</p>
</div></blockquote>
<p><strong>prox_control</strong> : <cite>[None, dict]</cite></p>
<blockquote>
<div><p>This argument is ignored for seminorms, but otherwise
is passed to <cite>regreg.algorithms.FISTA</cite> if the atom
needs to be solved iteratively.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of the implied center of <cite>quadratic</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.proximal_optimum">
<code class="sig-name descname">proximal_optimum</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.proximal_optimum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.proximal_step">
<code class="sig-name descname">proximal_step</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.proximal_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the proximal optimization</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>prox_control: [None, dict]</strong></p>
<blockquote>
<div><p>If not None, then a dictionary of parameters for the prox procedure</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.quadratic">
<em class="property">property </em><code class="sig-name descname">quadratic</code><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Quadratic part of the object, instance of <cite>regreg.identity_quadratic.identity_quadratic</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.seminorm">
<code class="sig-name descname">seminorm</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.seminorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math notranslate nohighlight">\(\lambda \cdot \|B\|_{1,1}\)</span>, where
<span class="math notranslate nohighlight">\(\lambda\)</span> is <cite>lagrange</cite>. If <cite>check_feasibility</cite>
is <cite>True</cite>, and seminorm is unbounded, will return <cite>np.inf</cite>
if appropriate.</p>
<p>The class seminorm’s seminorm just returns the appropriate lagrange
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.seminorms">
<code class="sig-name descname">seminorms</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.seminorms" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all seminorms in the block norm.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.set_bound">
<code class="sig-name descname">set_bound</code><span class="sig-paren">(</span><em class="sig-param">bound</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.set_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l1</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l1</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in lagrange mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.set_lagrange">
<code class="sig-name descname">set_lagrange</code><span class="sig-paren">(</span><em class="sig-param">lagrange</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.set_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l1</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l1</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in bound mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.set_offset">
<code class="sig-name descname">set_offset</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.set_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.set_quadratic">
<code class="sig-name descname">set_quadratic</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.set_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.shift">
<em class="property">classmethod </em><code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.shift" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.smooth_objective">
<code class="sig-name descname">smooth_objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">mode='both'</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.smooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The zero function.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.smoothed">
<code class="sig-name descname">smoothed</code><span class="sig-paren">(</span><em class="sig-param">smoothing_quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.smoothed" title="Permalink to this definition">¶</a></dt>
<dd><p>Add quadratic smoothing term</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l1.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">quadratic=None</em>, <em class="sig-param">return_optimum=False</em>, <em class="sig-param">**fit_args</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.l1_l1.tol">
<code class="sig-name descname">tol</code><em class="property"> = 1e-05</em><a class="headerlink" href="#regreg.atoms.block_norms.l1_l1.tol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="l1-l2">
<h3><a class="reference internal" href="#regreg.atoms.block_norms.l1_l2" title="regreg.atoms.block_norms.l1_l2"><code class="xref py py-class docutils literal notranslate"><span class="pre">l1_l2</span></code></a><a class="headerlink" href="#l1-l2" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="regreg.atoms.block_norms.l1_l2">
<em class="property">class </em><code class="sig-prename descclassname">regreg.atoms.block_norms.</code><code class="sig-name descname">l1_l2</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#regreg.atoms.block_norms.block_sum" title="regreg.atoms.block_norms.block_sum"><code class="xref py py-class docutils literal notranslate"><span class="pre">regreg.atoms.block_norms.block_sum</span></code></a></p>
<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.affine">
<em class="property">classmethod </em><code class="sig-name descname">affine</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the same as the linear class method but with offset as a positional argument</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.apply_offset">
<code class="sig-name descname">apply_offset</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.apply_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>If self.offset is not None, return x-self.offset, else return x.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.bound">
<em class="property">property </em><code class="sig-name descname">bound</code><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.bound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.bound_prox">
<code class="sig-name descname">bound_prox</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">bound=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.bound_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\delta}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{n \times p}} 
\frac{1}{2}
\|\theta-B\|^2_2  \ 
\text{s.t.} \   \|B\|_{1,2} \leq \delta\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta\)</span> is the bound parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>bound</cite> is None and the atom is in bound mode,
<code class="docutils literal notranslate"><span class="pre">self.bound</span></code> is used as the bound parameter, else an exception is
raised.</p>
<p>The class atom’s bound_prox just returns the appropriate bound
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>bound</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Bound for the constraint on the seminorm.
Defaults to <cite>self.bound</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.check_subgradient">
<em class="property">static </em><code class="sig-name descname">check_subgradient</code><span class="sig-paren">(</span><em class="sig-param">atom</em>, <em class="sig-param">prox_center</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.check_subgradient" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given seminorm, verify the KKT condition for
the problem for the proximal problem</p>
<div class="math notranslate nohighlight">
\[\text{minimize}_u \frac{1}{2} \|u-z\|^2_2 + h(z)\]</div>
<p>where <span class="math notranslate nohighlight">\(z\)</span> is the <cite>prox_center</cite> and <span class="math notranslate nohighlight">\(h\)</span> is <cite>atom</cite>
which may be in Lagrange or bound form.</p>
<p>If the atom is in Lagrange form, this function should
return two values equal to the seminorm of the 
minimizer. If it is bound form it should return two values
equal to the dual seminorm of the residual, i.e.
the prox_center minus the minimizer.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>atom</strong> : <cite>seminorm</cite></p>
<p><strong>prox_center</strong> : np.ndarray(np.float)</p>
<blockquote>
<div><p>Center for the proximal map.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>v1, v2</strong> : float</p>
<blockquote>
<div><p>Two values that should be equal if the proximal map is correct.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.conjugate">
<em class="property">property </em><code class="sig-name descname">conjugate</code><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.conjugate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.constraint">
<code class="sig-name descname">constraint</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify <span class="math notranslate nohighlight">\(\|B\|_{1,2} \leq \delta\)</span>, where <span class="math notranslate nohighlight">\(\delta\)</span>
is <cite>bound</cite>.</p>
<p>If the result is <cite>True</cite>, returns 0, else returns <cite>np.inf</cite>.</p>
<p>The class seminorm’s constraint just returns the appropriate bound
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.dual">
<em class="property">property </em><code class="sig-name descname">dual</code><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.dual" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.get_bound">
<code class="sig-name descname">get_bound</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.get_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.get_conjugate">
<code class="sig-name descname">get_conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.get_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the conjugate of an given atom.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">get_conjugate</span><span class="p">()</span> 
<span class="go">linf_l2(..., bound=3.4...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.get_dual">
<code class="sig-name descname">get_dual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.get_dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual of an atom. This dual is formed by making introducing
new variables <span class="math notranslate nohighlight">\(v=Ax\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is <cite>self.linear_transform</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> 
<span class="go">l1_l2(..., lagrange=2.3...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.identity object at 0x...&gt;, linf_l2(..., bound=2.3...))</span>
</pre></div>
</div>
<p>If there is a linear part to the penalty, the linear_transform may not be 
identity. For example, the 1D fused LASSO penalty:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="mi">1</span><span class="p">))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span>
<span class="go">array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> 
<span class="go">affine_atom(l1norm((3,), lagrange=2.3...), array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.linear_transform object at 0x...&gt;, supnorm((3,), bound=2.3...))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.get_lagrange">
<code class="sig-name descname">get_lagrange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.get_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.get_offset">
<code class="sig-name descname">get_offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.get_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.get_quadratic">
<code class="sig-name descname">get_quadratic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.get_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.lagrange">
<em class="property">property </em><code class="sig-name descname">lagrange</code><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.lagrange" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.lagrange_prox">
<code class="sig-name descname">lagrange_prox</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">lipschitz=1</em>, <em class="sig-param">lagrange=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.lagrange_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\lambda}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{n \times p}} 
\frac{L}{2}
\|\theta-B\|^2_2 + \lambda \|B\|_{1,2} \]</div>
<p>Above, <span class="math notranslate nohighlight">\(\lambda\)</span> is the Lagrange parameter and <span class="math notranslate nohighlight">\(L\)</span>
is the Lipschitz parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>lagrange</cite> is None and the atom is in lagrange mode,
<code class="docutils literal notranslate"><span class="pre">self.lagrange</span></code> is used as the lagrange parameter, else an exception
is raised.</p>
<p>The class atom’s lagrange_prox just returns the appropriate lagrange
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>lipschitz</strong> : <cite>float</cite></p>
<blockquote>
<div><p>Coefficient in front of the quadratic.</p>
</div></blockquote>
<p><strong>lagrange</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Lagrange factor in front of the seminorm. 
Defaults to <cite>self.lagrange</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.latexify">
<code class="sig-name descname">latexify</code><span class="sig-paren">(</span><em class="sig-param">var=None</em>, <em class="sig-param">idx=''</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.latexify" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a LaTeX representation of an object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">latexify</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\gamma&#39;</span><span class="p">)</span> 
<span class="go">&#39;\\lambda_{} \\|\\gamma\\|_1&#39;</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>var</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Argument of the functions</p>
</div></blockquote>
<p><strong>idx</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Optional subscript index.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>L</strong> : <cite>string</cite></p>
<blockquote>
<div><p>A LaTeX representation of the atom.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.linear">
<em class="property">classmethod </em><code class="sig-name descname">linear</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">offset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.linear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.linear_transform">
<em class="property">property </em><code class="sig-name descname">linear_transform</code><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.linear_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The linear transform applied before a penalty is computed. Defaults to regreg.affine.identity</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">regreg.api</span> <span class="k">import</span> <span class="n">l1norm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">l1norm</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">penalty</span><span class="o">.</span><span class="n">linear_transform</span><span class="p">)</span>
<span class="go">&lt;class &#39;regreg.affine.identity&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.nonsmooth_objective">
<code class="sig-name descname">nonsmooth_objective</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.nonsmooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The nonsmooth objective function of the atom.
Includes <cite>self.quadratic.objective(arg)</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">nonsmooth_objective</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the seminorm.</p>
</div></blockquote>
<p><strong>check_feasibility</strong> : <cite>bool</cite></p>
<blockquote>
<div><p>If <cite>True</cite>, then return <cite>np.inf</cite> if appropriate.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> : <cite>np.float</cite></p>
<blockquote>
<div><p>The seminorm of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.objective">
<code class="sig-name descname">objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.objective" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.l1_l2.objective_template">
<code class="sig-name descname">objective_template</code><em class="property"> = '\\|%(var)s\\|_{1,2}'</em><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.objective_template" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.l1_l2.objective_vars">
<code class="sig-name descname">objective_vars</code><em class="property"> = {'dualnormklass': 'linf_l2', 'initargs': '(5,4)', 'linear': 'D', 'normklass': 'l1_l2', 'offset': '\\alpha', 'shape': 'n \\times p', 'var': 'B'}</em><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.objective_vars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.offset">
<em class="property">property </em><code class="sig-name descname">offset</code><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>The proximal operator. If the atom is in
Lagrange mode, this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\lambda}(\theta) = \text{argmin}_{B \in
\mathbb{R}^{n \times p}} \frac{L}{2} \|\theta-B\|^2_2
+ \lambda h(B-\alpha) + \langle B, \eta \rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is <cite>self.offset</cite>,
<span class="math notranslate nohighlight">\(\eta\)</span> is <cite>quadratic.linear_term</cite>, <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>quadratic.center</cite> and</p>
<div class="math notranslate nohighlight">
\[h(B) = \|B\|_{1,2}\]</div>
<p>If the atom is in bound mode, then this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\delta}(\theta) = \text{argmin}_{B \in \mathbb{R}^{n \times p}} \frac{L}{2}
\|\theta-B\|^2_2 + \langle B, \eta \rangle \  \text{s.t.} \   
h(B - \alpha) \leq \delta\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">identity_quadratic</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> 
<span class="go">array([ 1.6666..., -2.6666..., -0.        ,  0.        ])</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>quadratic</strong> : <cite>regreg.identity_quadratic.identity_quadratic</cite></p>
<blockquote>
<div><p>A quadratic added to the atom before minimizing.</p>
</div></blockquote>
<p><strong>prox_control</strong> : <cite>[None, dict]</cite></p>
<blockquote>
<div><p>This argument is ignored for seminorms, but otherwise
is passed to <cite>regreg.algorithms.FISTA</cite> if the atom
needs to be solved iteratively.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of the implied center of <cite>quadratic</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.proximal_optimum">
<code class="sig-name descname">proximal_optimum</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.proximal_optimum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.proximal_step">
<code class="sig-name descname">proximal_step</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.proximal_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the proximal optimization</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>prox_control: [None, dict]</strong></p>
<blockquote>
<div><p>If not None, then a dictionary of parameters for the prox procedure</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.quadratic">
<em class="property">property </em><code class="sig-name descname">quadratic</code><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Quadratic part of the object, instance of <cite>regreg.identity_quadratic.identity_quadratic</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.seminorm">
<code class="sig-name descname">seminorm</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.seminorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math notranslate nohighlight">\(\lambda \cdot \|B\|_{1,2}\)</span>, where
<span class="math notranslate nohighlight">\(\lambda\)</span> is <cite>lagrange</cite>. If <cite>check_feasibility</cite>
is <cite>True</cite>, and seminorm is unbounded, will return <cite>np.inf</cite>
if appropriate.</p>
<p>The class seminorm’s seminorm just returns the appropriate lagrange
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.seminorms">
<code class="sig-name descname">seminorms</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.seminorms" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all seminorms in the block norm.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.set_bound">
<code class="sig-name descname">set_bound</code><span class="sig-paren">(</span><em class="sig-param">bound</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.set_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in lagrange mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.set_lagrange">
<code class="sig-name descname">set_lagrange</code><span class="sig-paren">(</span><em class="sig-param">lagrange</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.set_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in bound mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.set_offset">
<code class="sig-name descname">set_offset</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.set_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.set_quadratic">
<code class="sig-name descname">set_quadratic</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.set_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.shift">
<em class="property">classmethod </em><code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.shift" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.smooth_objective">
<code class="sig-name descname">smooth_objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">mode='both'</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.smooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The zero function.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.smoothed">
<code class="sig-name descname">smoothed</code><span class="sig-paren">(</span><em class="sig-param">smoothing_quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.smoothed" title="Permalink to this definition">¶</a></dt>
<dd><p>Add quadratic smoothing term</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.l1_l2.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">quadratic=None</em>, <em class="sig-param">return_optimum=False</em>, <em class="sig-param">**fit_args</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.l1_l2.tol">
<code class="sig-name descname">tol</code><em class="property"> = 1e-05</em><a class="headerlink" href="#regreg.atoms.block_norms.l1_l2.tol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="linf-l2">
<h3><a class="reference internal" href="#regreg.atoms.block_norms.linf_l2" title="regreg.atoms.block_norms.linf_l2"><code class="xref py py-class docutils literal notranslate"><span class="pre">linf_l2</span></code></a><a class="headerlink" href="#linf-l2" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="regreg.atoms.block_norms.linf_l2">
<em class="property">class </em><code class="sig-prename descclassname">regreg.atoms.block_norms.</code><code class="sig-name descname">linf_l2</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#regreg.atoms.block_norms.block_max" title="regreg.atoms.block_norms.block_max"><code class="xref py py-class docutils literal notranslate"><span class="pre">regreg.atoms.block_norms.block_max</span></code></a></p>
<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.affine">
<em class="property">classmethod </em><code class="sig-name descname">affine</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the same as the linear class method but with offset as a positional argument</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.apply_offset">
<code class="sig-name descname">apply_offset</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.apply_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>If self.offset is not None, return x-self.offset, else return x.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.bound">
<em class="property">property </em><code class="sig-name descname">bound</code><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.bound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.bound_prox">
<code class="sig-name descname">bound_prox</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">bound=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.bound_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\delta}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{n \times p}} 
\frac{1}{2}
\|\theta-B\|^2_2  \ 
\text{s.t.} \   \|B\|_{\infty,2} \leq \delta\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta\)</span> is the bound parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>bound</cite> is None and the atom is in bound mode,
<code class="docutils literal notranslate"><span class="pre">self.bound</span></code> is used as the bound parameter, else an exception is
raised.</p>
<p>The class atom’s bound_prox just returns the appropriate bound
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>bound</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Bound for the constraint on the seminorm.
Defaults to <cite>self.bound</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.check_subgradient">
<em class="property">static </em><code class="sig-name descname">check_subgradient</code><span class="sig-paren">(</span><em class="sig-param">atom</em>, <em class="sig-param">prox_center</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.check_subgradient" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given seminorm, verify the KKT condition for
the problem for the proximal problem</p>
<div class="math notranslate nohighlight">
\[\text{minimize}_u \frac{1}{2} \|u-z\|^2_2 + h(z)\]</div>
<p>where <span class="math notranslate nohighlight">\(z\)</span> is the <cite>prox_center</cite> and <span class="math notranslate nohighlight">\(h\)</span> is <cite>atom</cite>
which may be in Lagrange or bound form.</p>
<p>If the atom is in Lagrange form, this function should
return two values equal to the seminorm of the 
minimizer. If it is bound form it should return two values
equal to the dual seminorm of the residual, i.e.
the prox_center minus the minimizer.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>atom</strong> : <cite>seminorm</cite></p>
<p><strong>prox_center</strong> : np.ndarray(np.float)</p>
<blockquote>
<div><p>Center for the proximal map.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>v1, v2</strong> : float</p>
<blockquote>
<div><p>Two values that should be equal if the proximal map is correct.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.conjugate">
<em class="property">property </em><code class="sig-name descname">conjugate</code><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.conjugate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.constraint">
<code class="sig-name descname">constraint</code><span class="sig-paren">(</span><em class="sig-param">arg</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify <span class="math notranslate nohighlight">\(\|B\|_{\infty,2} \leq \delta\)</span>, where <span class="math notranslate nohighlight">\(\delta\)</span>
is <cite>bound</cite>.</p>
<p>If the result is <cite>True</cite>, returns 0, else returns <cite>np.inf</cite>.</p>
<p>The class seminorm’s constraint just returns the appropriate bound
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.dual">
<em class="property">property </em><code class="sig-name descname">dual</code><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.dual" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.get_bound">
<code class="sig-name descname">get_bound</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.get_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.get_conjugate">
<code class="sig-name descname">get_conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.get_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the conjugate of an given atom.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">get_conjugate</span><span class="p">()</span> 
<span class="go">l1_l2(..., bound=3.4...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.get_dual">
<code class="sig-name descname">get_dual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.get_dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual of an atom. This dual is formed by making introducing
new variables <span class="math notranslate nohighlight">\(v=Ax\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is <cite>self.linear_transform</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> 
<span class="go">linf_l2(..., lagrange=2.3...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.identity object at 0x...&gt;, l1_l2(..., bound=2.3...))</span>
</pre></div>
</div>
<p>If there is a linear part to the penalty, the linear_transform may not be 
identity. For example, the 1D fused LASSO penalty:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="mi">1</span><span class="p">))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span>
<span class="go">array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> 
<span class="go">affine_atom(l1norm((3,), lagrange=2.3...), array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.linear_transform object at 0x...&gt;, supnorm((3,), bound=2.3...))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.get_lagrange">
<code class="sig-name descname">get_lagrange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.get_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.get_offset">
<code class="sig-name descname">get_offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.get_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.get_quadratic">
<code class="sig-name descname">get_quadratic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.get_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.lagrange">
<em class="property">property </em><code class="sig-name descname">lagrange</code><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.lagrange" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.lagrange_prox">
<code class="sig-name descname">lagrange_prox</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">lipschitz=1</em>, <em class="sig-param">lagrange=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.lagrange_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\lambda}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{n \times p}} 
\frac{L}{2}
\|\theta-B\|^2_2 + \lambda \|B\|_{\infty,2} \]</div>
<p>Above, <span class="math notranslate nohighlight">\(\lambda\)</span> is the Lagrange parameter and <span class="math notranslate nohighlight">\(L\)</span>
is the Lipschitz parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>lagrange</cite> is None and the atom is in lagrange mode,
<code class="docutils literal notranslate"><span class="pre">self.lagrange</span></code> is used as the lagrange parameter, else an exception
is raised.</p>
<p>The class atom’s lagrange_prox just returns the appropriate lagrange
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>lipschitz</strong> : <cite>float</cite></p>
<blockquote>
<div><p>Coefficient in front of the quadratic.</p>
</div></blockquote>
<p><strong>lagrange</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Lagrange factor in front of the seminorm. 
Defaults to <cite>self.lagrange</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.latexify">
<code class="sig-name descname">latexify</code><span class="sig-paren">(</span><em class="sig-param">var=None</em>, <em class="sig-param">idx=''</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.latexify" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a LaTeX representation of an object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">latexify</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\gamma&#39;</span><span class="p">)</span> 
<span class="go">&#39;\\lambda_{} \\|\\gamma\\|_1&#39;</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>var</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Argument of the functions</p>
</div></blockquote>
<p><strong>idx</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Optional subscript index.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>L</strong> : <cite>string</cite></p>
<blockquote>
<div><p>A LaTeX representation of the atom.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.linear">
<em class="property">classmethod </em><code class="sig-name descname">linear</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">offset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.linear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.linear_transform">
<em class="property">property </em><code class="sig-name descname">linear_transform</code><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.linear_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The linear transform applied before a penalty is computed. Defaults to regreg.affine.identity</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">regreg.api</span> <span class="k">import</span> <span class="n">l1norm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">l1norm</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">penalty</span><span class="o">.</span><span class="n">linear_transform</span><span class="p">)</span>
<span class="go">&lt;class &#39;regreg.affine.identity&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.nonsmooth_objective">
<code class="sig-name descname">nonsmooth_objective</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.nonsmooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The nonsmooth objective function of the atom.
Includes <cite>self.quadratic.objective(arg)</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">nonsmooth_objective</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the seminorm.</p>
</div></blockquote>
<p><strong>check_feasibility</strong> : <cite>bool</cite></p>
<blockquote>
<div><p>If <cite>True</cite>, then return <cite>np.inf</cite> if appropriate.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> : <cite>np.float</cite></p>
<blockquote>
<div><p>The seminorm of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.objective">
<code class="sig-name descname">objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.objective" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.linf_l2.objective_template">
<code class="sig-name descname">objective_template</code><em class="property"> = '\\|%(var)s\\|_{\\infty,2}'</em><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.objective_template" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.linf_l2.objective_vars">
<code class="sig-name descname">objective_vars</code><em class="property"> = {'dualnormklass': 'l1_l2', 'initargs': '(5,4)', 'linear': 'D', 'normklass': 'linf_l2', 'offset': '\\alpha', 'shape': 'n \\times p', 'var': 'B'}</em><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.objective_vars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.offset">
<em class="property">property </em><code class="sig-name descname">offset</code><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>The proximal operator. If the atom is in
Lagrange mode, this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\lambda}(\theta) = \text{argmin}_{B \in
\mathbb{R}^{n \times p}} \frac{L}{2} \|\theta-B\|^2_2
+ \lambda h(B-\alpha) + \langle B, \eta \rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is <cite>self.offset</cite>,
<span class="math notranslate nohighlight">\(\eta\)</span> is <cite>quadratic.linear_term</cite>, <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>quadratic.center</cite> and</p>
<div class="math notranslate nohighlight">
\[h(B) = \|B\|_{\infty,2}\]</div>
<p>If the atom is in bound mode, then this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\delta}(\theta) = \text{argmin}_{B \in \mathbb{R}^{n \times p}} \frac{L}{2}
\|\theta-B\|^2_2 + \langle B, \eta \rangle \  \text{s.t.} \   
h(B - \alpha) \leq \delta\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">identity_quadratic</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> 
<span class="go">array([ 1.6666..., -2.6666..., -0.        ,  0.        ])</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>quadratic</strong> : <cite>regreg.identity_quadratic.identity_quadratic</cite></p>
<blockquote>
<div><p>A quadratic added to the atom before minimizing.</p>
</div></blockquote>
<p><strong>prox_control</strong> : <cite>[None, dict]</cite></p>
<blockquote>
<div><p>This argument is ignored for seminorms, but otherwise
is passed to <cite>regreg.algorithms.FISTA</cite> if the atom
needs to be solved iteratively.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of the implied center of <cite>quadratic</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.proximal_optimum">
<code class="sig-name descname">proximal_optimum</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.proximal_optimum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.proximal_step">
<code class="sig-name descname">proximal_step</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.proximal_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the proximal optimization</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>prox_control: [None, dict]</strong></p>
<blockquote>
<div><p>If not None, then a dictionary of parameters for the prox procedure</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.quadratic">
<em class="property">property </em><code class="sig-name descname">quadratic</code><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Quadratic part of the object, instance of <cite>regreg.identity_quadratic.identity_quadratic</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.seminorm">
<code class="sig-name descname">seminorm</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.seminorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math notranslate nohighlight">\(\lambda \cdot \|B\|_{\infty,2}\)</span>, where
<span class="math notranslate nohighlight">\(\lambda\)</span> is <cite>lagrange</cite>. If <cite>check_feasibility</cite>
is <cite>True</cite>, and seminorm is unbounded, will return <cite>np.inf</cite>
if appropriate.</p>
<p>The class seminorm’s seminorm just returns the appropriate lagrange
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.seminorms">
<code class="sig-name descname">seminorms</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.seminorms" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all seminorms in the block norm.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.set_bound">
<code class="sig-name descname">set_bound</code><span class="sig-paren">(</span><em class="sig-param">bound</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.set_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in lagrange mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.set_lagrange">
<code class="sig-name descname">set_lagrange</code><span class="sig-paren">(</span><em class="sig-param">lagrange</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.set_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_l2</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in bound mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.set_offset">
<code class="sig-name descname">set_offset</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.set_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.set_quadratic">
<code class="sig-name descname">set_quadratic</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.set_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.shift">
<em class="property">classmethod </em><code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.shift" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.smooth_objective">
<code class="sig-name descname">smooth_objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">mode='both'</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.smooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The zero function.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.smoothed">
<code class="sig-name descname">smoothed</code><span class="sig-paren">(</span><em class="sig-param">smoothing_quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.smoothed" title="Permalink to this definition">¶</a></dt>
<dd><p>Add quadratic smoothing term</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_l2.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">quadratic=None</em>, <em class="sig-param">return_optimum=False</em>, <em class="sig-param">**fit_args</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.linf_l2.tol">
<code class="sig-name descname">tol</code><em class="property"> = 1e-05</em><a class="headerlink" href="#regreg.atoms.block_norms.linf_l2.tol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="linf-linf">
<h3><a class="reference internal" href="#regreg.atoms.block_norms.linf_linf" title="regreg.atoms.block_norms.linf_linf"><code class="xref py py-class docutils literal notranslate"><span class="pre">linf_linf</span></code></a><a class="headerlink" href="#linf-linf" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="regreg.atoms.block_norms.linf_linf">
<em class="property">class </em><code class="sig-prename descclassname">regreg.atoms.block_norms.</code><code class="sig-name descname">linf_linf</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#regreg.atoms.block_norms.linf_l2" title="regreg.atoms.block_norms.linf_l2"><code class="xref py py-class docutils literal notranslate"><span class="pre">regreg.atoms.block_norms.linf_l2</span></code></a></p>
<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.affine">
<em class="property">classmethod </em><code class="sig-name descname">affine</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the same as the linear class method but with offset as a positional argument</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.apply_offset">
<code class="sig-name descname">apply_offset</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.apply_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>If self.offset is not None, return x-self.offset, else return x.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.bound">
<em class="property">property </em><code class="sig-name descname">bound</code><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.bound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.bound_prox">
<code class="sig-name descname">bound_prox</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">bound=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.bound_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\delta}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{n \times p}} 
\frac{1}{2}
\|\theta-B\|^2_2  \ 
\text{s.t.} \   \|B\|_{\infty,\infty} \leq \delta\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta\)</span> is the bound parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>bound</cite> is None and the atom is in bound mode,
<code class="docutils literal notranslate"><span class="pre">self.bound</span></code> is used as the bound parameter, else an exception is
raised.</p>
<p>The class atom’s bound_prox just returns the appropriate bound
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>bound</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Bound for the constraint on the seminorm.
Defaults to <cite>self.bound</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.check_subgradient">
<em class="property">static </em><code class="sig-name descname">check_subgradient</code><span class="sig-paren">(</span><em class="sig-param">atom</em>, <em class="sig-param">prox_center</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.check_subgradient" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given seminorm, verify the KKT condition for
the problem for the proximal problem</p>
<div class="math notranslate nohighlight">
\[\text{minimize}_u \frac{1}{2} \|u-z\|^2_2 + h(z)\]</div>
<p>where <span class="math notranslate nohighlight">\(z\)</span> is the <cite>prox_center</cite> and <span class="math notranslate nohighlight">\(h\)</span> is <cite>atom</cite>
which may be in Lagrange or bound form.</p>
<p>If the atom is in Lagrange form, this function should
return two values equal to the seminorm of the 
minimizer. If it is bound form it should return two values
equal to the dual seminorm of the residual, i.e.
the prox_center minus the minimizer.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>atom</strong> : <cite>seminorm</cite></p>
<p><strong>prox_center</strong> : np.ndarray(np.float)</p>
<blockquote>
<div><p>Center for the proximal map.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>v1, v2</strong> : float</p>
<blockquote>
<div><p>Two values that should be equal if the proximal map is correct.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.conjugate">
<em class="property">property </em><code class="sig-name descname">conjugate</code><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.conjugate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.constraint">
<code class="sig-name descname">constraint</code><span class="sig-paren">(</span><em class="sig-param">arg</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify <span class="math notranslate nohighlight">\(\|B\|_{\infty,\infty} \leq \delta\)</span>, where <span class="math notranslate nohighlight">\(\delta\)</span>
is <cite>bound</cite>.</p>
<p>If the result is <cite>True</cite>, returns 0, else returns <cite>np.inf</cite>.</p>
<p>The class seminorm’s constraint just returns the appropriate bound
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.dual">
<em class="property">property </em><code class="sig-name descname">dual</code><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.dual" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.get_bound">
<code class="sig-name descname">get_bound</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.get_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_linf</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.get_conjugate">
<code class="sig-name descname">get_conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.get_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the conjugate of an given atom.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_linf</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">get_conjugate</span><span class="p">()</span> 
<span class="go">l1_l1(..., bound=3.4...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.get_dual">
<code class="sig-name descname">get_dual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.get_dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual of an atom. This dual is formed by making introducing
new variables <span class="math notranslate nohighlight">\(v=Ax\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is <cite>self.linear_transform</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_linf</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> 
<span class="go">linf_linf(..., lagrange=2.3...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.identity object at 0x...&gt;, l1_l1(..., bound=2.3...))</span>
</pre></div>
</div>
<p>If there is a linear part to the penalty, the linear_transform may not be 
identity. For example, the 1D fused LASSO penalty:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="mi">1</span><span class="p">))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span>
<span class="go">array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> 
<span class="go">affine_atom(l1norm((3,), lagrange=2.3...), array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.linear_transform object at 0x...&gt;, supnorm((3,), bound=2.3...))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.get_lagrange">
<code class="sig-name descname">get_lagrange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.get_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_linf</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.get_offset">
<code class="sig-name descname">get_offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.get_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.get_quadratic">
<code class="sig-name descname">get_quadratic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.get_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.lagrange">
<em class="property">property </em><code class="sig-name descname">lagrange</code><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.lagrange" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.lagrange_prox">
<code class="sig-name descname">lagrange_prox</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">lipschitz=1</em>, <em class="sig-param">lagrange=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.lagrange_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\lambda}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{n \times p}} 
\frac{L}{2}
\|\theta-B\|^2_2 + \lambda \|B\|_{\infty,\infty} \]</div>
<p>Above, <span class="math notranslate nohighlight">\(\lambda\)</span> is the Lagrange parameter and <span class="math notranslate nohighlight">\(L\)</span>
is the Lipschitz parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>lagrange</cite> is None and the atom is in lagrange mode,
<code class="docutils literal notranslate"><span class="pre">self.lagrange</span></code> is used as the lagrange parameter, else an exception
is raised.</p>
<p>The class atom’s lagrange_prox just returns the appropriate lagrange
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>lipschitz</strong> : <cite>float</cite></p>
<blockquote>
<div><p>Coefficient in front of the quadratic.</p>
</div></blockquote>
<p><strong>lagrange</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Lagrange factor in front of the seminorm. 
Defaults to <cite>self.lagrange</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.latexify">
<code class="sig-name descname">latexify</code><span class="sig-paren">(</span><em class="sig-param">var=None</em>, <em class="sig-param">idx=''</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.latexify" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a LaTeX representation of an object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">latexify</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\gamma&#39;</span><span class="p">)</span> 
<span class="go">&#39;\\lambda_{} \\|\\gamma\\|_1&#39;</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>var</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Argument of the functions</p>
</div></blockquote>
<p><strong>idx</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Optional subscript index.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>L</strong> : <cite>string</cite></p>
<blockquote>
<div><p>A LaTeX representation of the atom.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.linear">
<em class="property">classmethod </em><code class="sig-name descname">linear</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">offset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.linear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.linear_transform">
<em class="property">property </em><code class="sig-name descname">linear_transform</code><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.linear_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The linear transform applied before a penalty is computed. Defaults to regreg.affine.identity</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">regreg.api</span> <span class="k">import</span> <span class="n">l1norm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">l1norm</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">penalty</span><span class="o">.</span><span class="n">linear_transform</span><span class="p">)</span>
<span class="go">&lt;class &#39;regreg.affine.identity&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.nonsmooth_objective">
<code class="sig-name descname">nonsmooth_objective</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.nonsmooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The nonsmooth objective function of the atom.
Includes <cite>self.quadratic.objective(arg)</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">nonsmooth_objective</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the seminorm.</p>
</div></blockquote>
<p><strong>check_feasibility</strong> : <cite>bool</cite></p>
<blockquote>
<div><p>If <cite>True</cite>, then return <cite>np.inf</cite> if appropriate.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> : <cite>np.float</cite></p>
<blockquote>
<div><p>The seminorm of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.objective">
<code class="sig-name descname">objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.objective" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.linf_linf.objective_template">
<code class="sig-name descname">objective_template</code><em class="property"> = '\\|%(var)s\\|_{\\infty,\\infty}'</em><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.objective_template" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.linf_linf.objective_vars">
<code class="sig-name descname">objective_vars</code><em class="property"> = {'dualnormklass': 'l1_l1', 'initargs': '(5,4)', 'linear': 'D', 'normklass': 'linf_linf', 'offset': '\\alpha', 'shape': 'n \\times p', 'var': 'B'}</em><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.objective_vars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.offset">
<em class="property">property </em><code class="sig-name descname">offset</code><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>The proximal operator. If the atom is in
Lagrange mode, this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\lambda}(\theta) = \text{argmin}_{B \in
\mathbb{R}^{n \times p}} \frac{L}{2} \|\theta-B\|^2_2
+ \lambda h(B-\alpha) + \langle B, \eta \rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is <cite>self.offset</cite>,
<span class="math notranslate nohighlight">\(\eta\)</span> is <cite>quadratic.linear_term</cite>, <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>quadratic.center</cite> and</p>
<div class="math notranslate nohighlight">
\[h(B) = \|B\|_{\infty,\infty}\]</div>
<p>If the atom is in bound mode, then this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\delta}(\theta) = \text{argmin}_{B \in \mathbb{R}^{n \times p}} \frac{L}{2}
\|\theta-B\|^2_2 + \langle B, \eta \rangle \  \text{s.t.} \   
h(B - \alpha) \leq \delta\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">identity_quadratic</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> 
<span class="go">array([ 1.6666..., -2.6666..., -0.        ,  0.        ])</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>quadratic</strong> : <cite>regreg.identity_quadratic.identity_quadratic</cite></p>
<blockquote>
<div><p>A quadratic added to the atom before minimizing.</p>
</div></blockquote>
<p><strong>prox_control</strong> : <cite>[None, dict]</cite></p>
<blockquote>
<div><p>This argument is ignored for seminorms, but otherwise
is passed to <cite>regreg.algorithms.FISTA</cite> if the atom
needs to be solved iteratively.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of the implied center of <cite>quadratic</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.proximal_optimum">
<code class="sig-name descname">proximal_optimum</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.proximal_optimum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.proximal_step">
<code class="sig-name descname">proximal_step</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.proximal_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the proximal optimization</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>prox_control: [None, dict]</strong></p>
<blockquote>
<div><p>If not None, then a dictionary of parameters for the prox procedure</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.quadratic">
<em class="property">property </em><code class="sig-name descname">quadratic</code><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Quadratic part of the object, instance of <cite>regreg.identity_quadratic.identity_quadratic</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.seminorm">
<code class="sig-name descname">seminorm</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.seminorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math notranslate nohighlight">\(\lambda \cdot \|B\|_{\infty,\infty}\)</span>, where
<span class="math notranslate nohighlight">\(\lambda\)</span> is <cite>lagrange</cite>. If <cite>check_feasibility</cite>
is <cite>True</cite>, and seminorm is unbounded, will return <cite>np.inf</cite>
if appropriate.</p>
<p>The class seminorm’s seminorm just returns the appropriate lagrange
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.seminorms">
<code class="sig-name descname">seminorms</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.seminorms" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all seminorms in the block norm.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.set_bound">
<code class="sig-name descname">set_bound</code><span class="sig-paren">(</span><em class="sig-param">bound</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.set_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_linf</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_linf</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in lagrange mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.set_lagrange">
<code class="sig-name descname">set_lagrange</code><span class="sig-paren">(</span><em class="sig-param">lagrange</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.set_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_linf</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">linf_linf</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in bound mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.set_offset">
<code class="sig-name descname">set_offset</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.set_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.set_quadratic">
<code class="sig-name descname">set_quadratic</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.set_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.shift">
<em class="property">classmethod </em><code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.shift" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.smooth_objective">
<code class="sig-name descname">smooth_objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">mode='both'</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.smooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The zero function.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.smoothed">
<code class="sig-name descname">smoothed</code><span class="sig-paren">(</span><em class="sig-param">smoothing_quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.smoothed" title="Permalink to this definition">¶</a></dt>
<dd><p>Add quadratic smoothing term</p>
</dd></dl>

<dl class="method">
<dt id="regreg.atoms.block_norms.linf_linf.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">quadratic=None</em>, <em class="sig-param">return_optimum=False</em>, <em class="sig-param">**fit_args</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.atoms.block_norms.linf_linf.tol">
<code class="sig-name descname">tol</code><em class="property"> = 1e-05</em><a class="headerlink" href="#regreg.atoms.block_norms.linf_linf.tol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="regreg.atoms.cones.html" class="btn btn-neutral float-right" title="atoms.cones" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="regreg.atoms.html" class="btn btn-neutral float-left" title="atoms" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2011-2017, B. Klingenberg &amp; J. Taylor
      <span class="lastupdated">
        Last updated on Sep 24, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
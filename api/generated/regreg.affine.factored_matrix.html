

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>RegReg &mdash; RegReg Docuentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="affine.fused_lasso" href="regreg.affine.fused_lasso.html" />
    <link rel="prev" title="affine" href="regreg.affine.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience, time
				 series">

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/templogo2.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                v0.1.3+9.g60e3aef
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../agenda.html">RegReg development</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../documentation.html">RegReg documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../download.html">Downloading and installing RegReg</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../algorithms.html">RegReg algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../license.html">RegReg License Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../docattribute.html">RegReg documentation attribution</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.html">affine</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">affine.factored_matrix</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-affine-factored-matrix">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">affine.factored_matrix</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.fused_lasso.html">affine.fused_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.image2d.html">affine.image2d</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.multiscale.html">affine.multiscale</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.algorithms.html">algorithms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.html">atoms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.block_norms.html">atoms.block_norms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.cones.html">atoms.cones</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.group_lasso.html">atoms.group_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.linear_constraints.html">atoms.linear_constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.mixed_lasso.html">atoms.mixed_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.seminorms.html">atoms.seminorms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.slope.html">atoms.slope</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.sparse_group_lasso.html">atoms.sparse_group_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.svd_norms.html">atoms.svd_norms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.weighted_atoms.html">atoms.weighted_atoms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.doctemplates.html">doctemplates</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.identity_quadratic.html">identity_quadratic</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.objdoctemplates.html">objdoctemplates</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.paths.html">paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.admm.html">problems.admm</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.composite.html">problems.composite</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.conjugate.html">problems.conjugate</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.container.html">problems.container</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.dual_problem.html">problems.dual_problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.separable.html">problems.separable</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.simple.html">problems.simple</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.html">smooth</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.glm.html">smooth.glm</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.losses.html">smooth.losses</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.quadratic.html">smooth.quadratic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Some examples illustrating basic objects in RegReg</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../documentation.html">RegReg documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../download.html">Downloading and installing RegReg</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../algorithms.html">RegReg algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../license.html">RegReg License Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../docattribute.html">RegReg documentation attribution</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.html">affine</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">affine.factored_matrix</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-affine-factored-matrix">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">affine.factored_matrix</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.fused_lasso.html">affine.fused_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.image2d.html">affine.image2d</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.affine.multiscale.html">affine.multiscale</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.algorithms.html">algorithms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.html">atoms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.block_norms.html">atoms.block_norms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.cones.html">atoms.cones</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.group_lasso.html">atoms.group_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.linear_constraints.html">atoms.linear_constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.mixed_lasso.html">atoms.mixed_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.seminorms.html">atoms.seminorms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.slope.html">atoms.slope</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.sparse_group_lasso.html">atoms.sparse_group_lasso</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.svd_norms.html">atoms.svd_norms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.atoms.weighted_atoms.html">atoms.weighted_atoms</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.doctemplates.html">doctemplates</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.identity_quadratic.html">identity_quadratic</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.objdoctemplates.html">objdoctemplates</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.paths.html">paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.admm.html">problems.admm</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.composite.html">problems.composite</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.conjugate.html">problems.conjugate</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.container.html">problems.container</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.dual_problem.html">problems.dual_problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.separable.html">problems.separable</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.problems.simple.html">problems.simple</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.html">smooth</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.glm.html">smooth.glm</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.losses.html">smooth.losses</a></li>
<li class="toctree-l3"><a class="reference internal" href="regreg.smooth.quadratic.html">smooth.quadratic</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">regreg</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../documentation.html">RegReg documentation</a> &raquo;</li>
        
          <li><a href="../index.html">API</a> &raquo;</li>
        
      <li>RegReg</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/api/generated/regreg.affine.factored_matrix.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="affine-factored-matrix">
<h1>affine.factored_matrix<a class="headerlink" href="#affine-factored-matrix" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-affine-factored-matrix">
<h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">affine.factored_matrix</span></code><a class="headerlink" href="#module-affine-factored-matrix" title="Permalink to this headline">¶</a></h2>
<p>Inheritance diagram for <code class="docutils literal notranslate"><span class="pre">regreg.affine.factored_matrix</span></code>:</p>
digraph inheritance06cbf8477c {
rankdir=LR;
size=&quot;8.0, 12.0&quot;;
  &quot;affine.factored_matrix.factored_matrix&quot; [URL=&quot;#regreg.affine.factored_matrix.factored_matrix&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;A class for storing the SVD of a linear_tranform. &quot;];
  &quot;affine.factored_matrix.nuclear_norm&quot; [URL=&quot;#regreg.affine.factored_matrix.nuclear_norm&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;The nuclear norm&quot;];
  &quot;atoms.svd_norms.nuclear_norm&quot; -&gt; &quot;affine.factored_matrix.nuclear_norm&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;affine.factored_matrix.operator_norm&quot; [URL=&quot;#regreg.affine.factored_matrix.operator_norm&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;];
  &quot;atoms.svd_norms.operator_norm&quot; -&gt; &quot;affine.factored_matrix.operator_norm&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;atoms.seminorms.seminorm&quot; [URL=&quot;regreg.atoms.seminorms.html#regreg.atoms.seminorms.seminorm&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;An atom that can be in lagrange or bound form.&quot;];
  &quot;regreg.atoms.atom&quot; -&gt; &quot;atoms.seminorms.seminorm&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;atoms.svd_norms.nuclear_norm&quot; [URL=&quot;regreg.atoms.svd_norms.html#regreg.atoms.svd_norms.nuclear_norm&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;The nuclear norm&quot;];
  &quot;atoms.svd_norms.svd_atom&quot; -&gt; &quot;atoms.svd_norms.nuclear_norm&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;atoms.svd_norms.operator_norm&quot; [URL=&quot;regreg.atoms.svd_norms.html#regreg.atoms.svd_norms.operator_norm&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;The operator norm&quot;];
  &quot;atoms.svd_norms.svd_atom&quot; -&gt; &quot;atoms.svd_norms.operator_norm&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;atoms.svd_norms.svd_atom&quot; [URL=&quot;regreg.atoms.svd_norms.html#regreg.atoms.svd_norms.svd_atom&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;];
  &quot;atoms.seminorms.seminorm&quot; -&gt; &quot;atoms.svd_norms.svd_atom&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;problems.composite.composite&quot; [URL=&quot;regreg.problems.composite.html#regreg.problems.composite.composite&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;A generic way to specify a problem in composite form.&quot;];
  &quot;problems.composite.nonsmooth&quot; [URL=&quot;regreg.problems.composite.html#regreg.problems.composite.nonsmooth&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;A composite subclass that explicitly returns 0&quot;];
  &quot;problems.composite.composite&quot; -&gt; &quot;problems.composite.nonsmooth&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
  &quot;regreg.atoms.atom&quot; [URL=&quot;regreg.atoms.html#regreg.atoms.atom&quot;,fontname=&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;,fontsize=10,height=0.25,shape=box,style=&quot;setlinewidth(0.5)&quot;,target=&quot;_top&quot;,tooltip=&quot;A class that defines the API for support functions.&quot;];
  &quot;problems.composite.nonsmooth&quot; -&gt; &quot;regreg.atoms.atom&quot; [arrowsize=0.5,style=&quot;setlinewidth(0.5)&quot;];
}
<span class="target" id="module-regreg.affine.factored_matrix"></span><p>This module contains the implementation operator and nuclear norms, used in 
matrix completion problems and other low-rank factorization
problems.</p>
</div>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="factored-matrix">
<h3><a class="reference internal" href="#regreg.affine.factored_matrix.factored_matrix" title="regreg.affine.factored_matrix.factored_matrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">factored_matrix</span></code></a><a class="headerlink" href="#factored-matrix" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="regreg.affine.factored_matrix.factored_matrix">
<em class="property">class </em><code class="sig-prename descclassname">regreg.affine.factored_matrix.</code><code class="sig-name descname">factored_matrix</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">min_singular=0.0</em>, <em class="sig-param">tol=1e-05</em>, <em class="sig-param">initial_rank=None</em>, <em class="sig-param">initial=None</em>, <em class="sig-param">affine_offset=None</em>, <em class="sig-param">debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.factored_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class for storing the SVD of a linear_tranform. 
Has affine_transform attributes like linear_map.</p>
<dl class="method">
<dt id="regreg.affine.factored_matrix.factored_matrix.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">min_singular=0.0</em>, <em class="sig-param">tol=1e-05</em>, <em class="sig-param">initial_rank=None</em>, <em class="sig-param">initial=None</em>, <em class="sig-param">affine_offset=None</em>, <em class="sig-param">debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.factored_matrix.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.factored_matrix.X">
<em class="property">property </em><code class="sig-name descname">X</code><a class="headerlink" href="#regreg.affine.factored_matrix.factored_matrix.X" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.factored_matrix.adjoint_map">
<code class="sig-name descname">adjoint_map</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.factored_matrix.adjoint_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.factored_matrix.affine_map">
<code class="sig-name descname">affine_map</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.factored_matrix.affine_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.factored_matrix.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.factored_matrix.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.factored_matrix.factors">
<em class="property">property </em><code class="sig-name descname">factors</code><a class="headerlink" href="#regreg.affine.factored_matrix.factored_matrix.factors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.factored_matrix.linear_map">
<code class="sig-name descname">linear_map</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.factored_matrix.linear_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.factored_matrix.offset_map">
<code class="sig-name descname">offset_map</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.factored_matrix.offset_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="nuclear-norm">
<h3><a class="reference internal" href="#regreg.affine.factored_matrix.nuclear_norm" title="regreg.affine.factored_matrix.nuclear_norm"><code class="xref py py-class docutils literal notranslate"><span class="pre">nuclear_norm</span></code></a><a class="headerlink" href="#nuclear-norm" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="regreg.affine.factored_matrix.nuclear_norm">
<em class="property">class </em><code class="sig-prename descclassname">regreg.affine.factored_matrix.</code><code class="sig-name descname">nuclear_norm</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em>, <em class="sig-param">initial_rank=10</em>, <em class="sig-param">warm_start=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="regreg.atoms.svd_norms.html#regreg.atoms.svd_norms.nuclear_norm" title="regreg.atoms.svd_norms.nuclear_norm"><code class="xref py py-class docutils literal notranslate"><span class="pre">regreg.atoms.svd_norms.nuclear_norm</span></code></a></p>
<p>The nuclear norm</p>
<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em>, <em class="sig-param">initial_rank=10</em>, <em class="sig-param">warm_start=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.affine">
<em class="property">classmethod </em><code class="sig-name descname">affine</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the same as the linear class method but with offset as a positional argument</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.apply_offset">
<code class="sig-name descname">apply_offset</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.apply_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>If self.offset is not None, return x-self.offset, else return x.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.bound">
<em class="property">property </em><code class="sig-name descname">bound</code><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.bound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.bound_prox">
<code class="sig-name descname">bound_prox</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">bound=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.bound_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\delta}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{{n \times p}}} 
\frac{1}{2}
\|\theta-B\|^2_2  \ 
\text{s.t.} \   \|B\|_* \leq \delta\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta\)</span> is the bound parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>bound</cite> is None and the atom is in bound mode,
<code class="docutils literal notranslate"><span class="pre">self.bound</span></code> is used as the bound parameter, else an exception is
raised.</p>
<p>The class atom’s bound_prox just returns the appropriate bound
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>bound</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Bound for the constraint on the seminorm.
Defaults to <cite>self.bound</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.check_subgradient">
<em class="property">static </em><code class="sig-name descname">check_subgradient</code><span class="sig-paren">(</span><em class="sig-param">atom</em>, <em class="sig-param">prox_center</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.check_subgradient" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given seminorm, verify the KKT condition for
the problem for the proximal problem</p>
<div class="math notranslate nohighlight">
\[\text{minimize}_u \frac{1}{2} \|u-z\|^2_2 + h(z)\]</div>
<p>where <span class="math notranslate nohighlight">\(z\)</span> is the <cite>prox_center</cite> and <span class="math notranslate nohighlight">\(h\)</span> is <cite>atom</cite>
which may be in Lagrange or bound form.</p>
<p>If the atom is in Lagrange form, this function should
return two values equal to the seminorm of the 
minimizer. If it is bound form it should return two values
equal to the dual seminorm of the residual, i.e.
the prox_center minus the minimizer.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>atom</strong> : <cite>seminorm</cite></p>
<p><strong>prox_center</strong> : np.ndarray(np.float)</p>
<blockquote>
<div><p>Center for the proximal map.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>v1, v2</strong> : float</p>
<blockquote>
<div><p>Two values that should be equal if the proximal map is correct.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.conjugate">
<em class="property">property </em><code class="sig-name descname">conjugate</code><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>The conjugate of an atom.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.constraint">
<code class="sig-name descname">constraint</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">bound=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify <span class="math notranslate nohighlight">\(\|B\|_* \leq \delta\)</span>, where <span class="math notranslate nohighlight">\(\delta\)</span>
is <cite>bound</cite>.</p>
<p>If the result is <cite>True</cite>, returns 0, else returns <cite>np.inf</cite>.</p>
<p>The class seminorm’s constraint just returns the appropriate bound
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.dual">
<em class="property">property </em><code class="sig-name descname">dual</code><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.dual" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.get_bound">
<code class="sig-name descname">get_bound</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.get_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">nuclear_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.get_conjugate">
<code class="sig-name descname">get_conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.get_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the conjugate of an given atom.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">nuclear_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">get_conjugate</span><span class="p">()</span> 
<span class="go">operator_norm(..., bound=3.4...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.get_dual">
<code class="sig-name descname">get_dual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.get_dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual of an atom. This dual is formed by making introducing
new variables <span class="math notranslate nohighlight">\(v=Ax\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is <cite>self.linear_transform</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">nuclear_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> 
<span class="go">nuclear_norm(..., lagrange=2.3...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.identity object at 0x...&gt;, operator_norm(..., bound=2.3...))</span>
</pre></div>
</div>
<p>If there is a linear part to the penalty, the linear_transform may not be 
identity. For example, the 1D fused LASSO penalty:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="mi">1</span><span class="p">))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span>
<span class="go">array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> 
<span class="go">affine_atom(l1norm((3,), lagrange=2.3...), array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.linear_transform object at 0x...&gt;, supnorm((3,), bound=2.3...))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.get_lagrange">
<code class="sig-name descname">get_lagrange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.get_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">nuclear_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.get_offset">
<code class="sig-name descname">get_offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.get_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.get_quadratic">
<code class="sig-name descname">get_quadratic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.get_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.lagrange">
<em class="property">property </em><code class="sig-name descname">lagrange</code><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.lagrange" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.lagrange_prox">
<code class="sig-name descname">lagrange_prox</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">lipschitz=1</em>, <em class="sig-param">lagrange=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.lagrange_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\lambda}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{{n \times p}}} 
\frac{L}{2}
\|\theta-B\|^2_2 + \lambda \|B\|_* \]</div>
<p>Above, <span class="math notranslate nohighlight">\(\lambda\)</span> is the Lagrange parameter and <span class="math notranslate nohighlight">\(L\)</span>
is the Lipschitz parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>lagrange</cite> is None and the atom is in lagrange mode,
<code class="docutils literal notranslate"><span class="pre">self.lagrange</span></code> is used as the lagrange parameter, else an exception
is raised.</p>
<p>The class atom’s lagrange_prox just returns the appropriate lagrange
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>lipschitz</strong> : <cite>float</cite></p>
<blockquote>
<div><p>Coefficient in front of the quadratic.</p>
</div></blockquote>
<p><strong>lagrange</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Lagrange factor in front of the seminorm. 
Defaults to <cite>self.lagrange</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.latexify">
<code class="sig-name descname">latexify</code><span class="sig-paren">(</span><em class="sig-param">var=None</em>, <em class="sig-param">idx=''</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.latexify" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a LaTeX representation of an object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">latexify</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\gamma&#39;</span><span class="p">)</span> 
<span class="go">&#39;\\lambda_{} \\|\\gamma\\|_1&#39;</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>var</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Argument of the functions</p>
</div></blockquote>
<p><strong>idx</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Optional subscript index.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>L</strong> : <cite>string</cite></p>
<blockquote>
<div><p>A LaTeX representation of the atom.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.linear">
<em class="property">classmethod </em><code class="sig-name descname">linear</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">offset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.linear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.linear_transform">
<em class="property">property </em><code class="sig-name descname">linear_transform</code><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.linear_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The linear transform applied before a penalty is computed. Defaults to regreg.affine.identity</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">regreg.api</span> <span class="k">import</span> <span class="n">l1norm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">l1norm</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">penalty</span><span class="o">.</span><span class="n">linear_transform</span><span class="p">)</span>
<span class="go">&lt;class &#39;regreg.affine.identity&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.nonsmooth_objective">
<code class="sig-name descname">nonsmooth_objective</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.nonsmooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The nonsmooth objective function of the atom.
Includes <cite>self.quadratic.objective(arg)</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">nonsmooth_objective</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the seminorm.</p>
</div></blockquote>
<p><strong>check_feasibility</strong> : <cite>bool</cite></p>
<blockquote>
<div><p>If <cite>True</cite>, then return <cite>np.inf</cite> if appropriate.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> : <cite>np.float</cite></p>
<blockquote>
<div><p>The seminorm of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.objective">
<code class="sig-name descname">objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.objective" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.affine.factored_matrix.nuclear_norm.objective_template">
<code class="sig-name descname">objective_template</code><em class="property"> = '\\|%(var)s\\|_*'</em><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.objective_template" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.affine.factored_matrix.nuclear_norm.objective_vars">
<code class="sig-name descname">objective_vars</code><em class="property"> = {'dualnormklass': 'operator_norm', 'initargs': '(5,4)', 'linear': 'D', 'normklass': 'nuclear_norm', 'offset': '\\alpha', 'shape': '{n \\times p}', 'var': 'B'}</em><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.objective_vars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.offset">
<em class="property">property </em><code class="sig-name descname">offset</code><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.affine.factored_matrix.nuclear_norm.prox_tol">
<code class="sig-name descname">prox_tol</code><em class="property"> = 1e-05</em><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.prox_tol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>The proximal operator. If the atom is in
Lagrange mode, this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\lambda}(\theta) = \text{argmin}_{B \in
\mathbb{R}^{{n \times p}}} \frac{L}{2} \|\theta-B\|^2_2
+ \lambda h(B-\alpha) + \langle B, \eta \rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is <cite>self.offset</cite>,
<span class="math notranslate nohighlight">\(\eta\)</span> is <cite>quadratic.linear_term</cite>, <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>quadratic.center</cite> and</p>
<div class="math notranslate nohighlight">
\[h(B) = \|B\|_*\]</div>
<p>If the atom is in bound mode, then this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\delta}(\theta) = \text{argmin}_{B \in \mathbb{R}^{{n \times p}}} \frac{L}{2}
\|\theta-B\|^2_2 + \langle B, \eta \rangle \  \text{s.t.} \   
h(B - \alpha) \leq \delta\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">identity_quadratic</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> 
<span class="go">array([ 1.6666..., -2.6666..., -0.        ,  0.        ])</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>quadratic</strong> : <cite>regreg.identity_quadratic.identity_quadratic</cite></p>
<blockquote>
<div><p>A quadratic added to the atom before minimizing.</p>
</div></blockquote>
<p><strong>prox_control</strong> : <cite>[None, dict]</cite></p>
<blockquote>
<div><p>This argument is ignored for seminorms, but otherwise
is passed to <cite>regreg.algorithms.FISTA</cite> if the atom
needs to be solved iteratively.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of the implied center of <cite>quadratic</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.proximal_optimum">
<code class="sig-name descname">proximal_optimum</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.proximal_optimum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.proximal_step">
<code class="sig-name descname">proximal_step</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.proximal_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the proximal optimization</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>prox_control: [None, dict]</strong></p>
<blockquote>
<div><p>If not None, then a dictionary of parameters for the prox procedure</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.quadratic">
<em class="property">property </em><code class="sig-name descname">quadratic</code><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Quadratic part of the object, instance of <cite>regreg.identity_quadratic.identity_quadratic</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.seminorm">
<code class="sig-name descname">seminorm</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">check_feasibility=False</em>, <em class="sig-param">lagrange=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.seminorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math notranslate nohighlight">\(\lambda \cdot \|B\|_*\)</span>, where
<span class="math notranslate nohighlight">\(\lambda\)</span> is <cite>lagrange</cite>. If <cite>check_feasibility</cite>
is <cite>True</cite>, and seminorm is unbounded, will return <cite>np.inf</cite>
if appropriate.</p>
<p>The class seminorm’s seminorm just returns the appropriate lagrange
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.set_bound">
<code class="sig-name descname">set_bound</code><span class="sig-paren">(</span><em class="sig-param">bound</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.set_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">nuclear_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">nuclear_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in lagrange mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.set_lagrange">
<code class="sig-name descname">set_lagrange</code><span class="sig-paren">(</span><em class="sig-param">lagrange</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.set_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">nuclear_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">nuclear_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in bound mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.set_offset">
<code class="sig-name descname">set_offset</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.set_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.set_quadratic">
<code class="sig-name descname">set_quadratic</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.set_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.shift">
<em class="property">classmethod </em><code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.shift" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.smooth_objective">
<code class="sig-name descname">smooth_objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">mode='both'</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.smooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The zero function.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.smoothed">
<code class="sig-name descname">smoothed</code><span class="sig-paren">(</span><em class="sig-param">smoothing_quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.smoothed" title="Permalink to this definition">¶</a></dt>
<dd><p>Add quadratic smoothing term</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.nuclear_norm.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">quadratic=None</em>, <em class="sig-param">return_optimum=False</em>, <em class="sig-param">**fit_args</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.affine.factored_matrix.nuclear_norm.svd_tol">
<code class="sig-name descname">svd_tol</code><em class="property"> = 1e-05</em><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.svd_tol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.affine.factored_matrix.nuclear_norm.tol">
<code class="sig-name descname">tol</code><em class="property"> = 1e-05</em><a class="headerlink" href="#regreg.affine.factored_matrix.nuclear_norm.tol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="operator-norm">
<h3><a class="reference internal" href="#regreg.affine.factored_matrix.operator_norm" title="regreg.affine.factored_matrix.operator_norm"><code class="xref py py-class docutils literal notranslate"><span class="pre">operator_norm</span></code></a><a class="headerlink" href="#operator-norm" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="regreg.affine.factored_matrix.operator_norm">
<em class="property">class </em><code class="sig-prename descclassname">regreg.affine.factored_matrix.</code><code class="sig-name descname">operator_norm</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em>, <em class="sig-param">initial_rank=10</em>, <em class="sig-param">warm_start=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="regreg.atoms.svd_norms.html#regreg.atoms.svd_norms.operator_norm" title="regreg.atoms.svd_norms.operator_norm"><code class="xref py py-class docutils literal notranslate"><span class="pre">regreg.atoms.svd_norms.operator_norm</span></code></a></p>
<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">initial=None</em>, <em class="sig-param">initial_rank=10</em>, <em class="sig-param">warm_start=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.affine">
<em class="property">classmethod </em><code class="sig-name descname">affine</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the same as the linear class method but with offset as a positional argument</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.apply_offset">
<code class="sig-name descname">apply_offset</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.apply_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>If self.offset is not None, return x-self.offset, else return x.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.bound">
<em class="property">property </em><code class="sig-name descname">bound</code><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.bound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.bound_prox">
<code class="sig-name descname">bound_prox</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">bound=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.bound_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\delta}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{{n \times p}}} 
\frac{1}{2}
\|\theta-B\|^2_2  \ 
\text{s.t.} \   \|B\|_{\text{op}} \leq \delta\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta\)</span> is the bound parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>bound</cite> is None and the atom is in bound mode,
<code class="docutils literal notranslate"><span class="pre">self.bound</span></code> is used as the bound parameter, else an exception is
raised.</p>
<p>The class atom’s bound_prox just returns the appropriate bound
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>bound</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Bound for the constraint on the seminorm.
Defaults to <cite>self.bound</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.check_subgradient">
<em class="property">static </em><code class="sig-name descname">check_subgradient</code><span class="sig-paren">(</span><em class="sig-param">atom</em>, <em class="sig-param">prox_center</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.check_subgradient" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given seminorm, verify the KKT condition for
the problem for the proximal problem</p>
<div class="math notranslate nohighlight">
\[\text{minimize}_u \frac{1}{2} \|u-z\|^2_2 + h(z)\]</div>
<p>where <span class="math notranslate nohighlight">\(z\)</span> is the <cite>prox_center</cite> and <span class="math notranslate nohighlight">\(h\)</span> is <cite>atom</cite>
which may be in Lagrange or bound form.</p>
<p>If the atom is in Lagrange form, this function should
return two values equal to the seminorm of the 
minimizer. If it is bound form it should return two values
equal to the dual seminorm of the residual, i.e.
the prox_center minus the minimizer.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>atom</strong> : <cite>seminorm</cite></p>
<p><strong>prox_center</strong> : np.ndarray(np.float)</p>
<blockquote>
<div><p>Center for the proximal map.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>v1, v2</strong> : float</p>
<blockquote>
<div><p>Two values that should be equal if the proximal map is correct.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.conjugate">
<em class="property">property </em><code class="sig-name descname">conjugate</code><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>The conjugate of an atom.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.constraint">
<code class="sig-name descname">constraint</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">bound=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify <span class="math notranslate nohighlight">\(\|B\|_{\text{op}} \leq \delta\)</span>, where <span class="math notranslate nohighlight">\(\delta\)</span>
is <cite>bound</cite>.</p>
<p>If the result is <cite>True</cite>, returns 0, else returns <cite>np.inf</cite>.</p>
<p>The class seminorm’s constraint just returns the appropriate bound
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.dual">
<em class="property">property </em><code class="sig-name descname">dual</code><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.dual" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.get_bound">
<code class="sig-name descname">get_bound</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.get_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">operator_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.get_conjugate">
<code class="sig-name descname">get_conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.get_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the conjugate of an given atom.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">operator_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">get_conjugate</span><span class="p">()</span> 
<span class="go">nuclear_norm(..., bound=3.4...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.get_dual">
<code class="sig-name descname">get_dual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.get_dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual of an atom. This dual is formed by making introducing
new variables <span class="math notranslate nohighlight">\(v=Ax\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is <cite>self.linear_transform</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">operator_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> 
<span class="go">operator_norm(..., lagrange=2.3...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.identity object at 0x...&gt;, nuclear_norm(..., bound=2.3...))</span>
</pre></div>
</div>
<p>If there is a linear part to the penalty, the linear_transform may not be 
identity. For example, the 1D fused LASSO penalty:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="mi">1</span><span class="p">))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span>
<span class="go">array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span> 
<span class="go">affine_atom(l1norm((3,), lagrange=2.3...), array([[ 1., -1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1., -1.]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_atom</span><span class="o">.</span><span class="n">dual</span> 
<span class="go">(&lt;regreg.affine.linear_transform object at 0x...&gt;, supnorm((3,), bound=2.3...))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.get_lagrange">
<code class="sig-name descname">get_lagrange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.get_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Get method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">operator_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.get_offset">
<code class="sig-name descname">get_offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.get_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.get_quadratic">
<code class="sig-name descname">get_quadratic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.get_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.lagrange">
<em class="property">property </em><code class="sig-name descname">lagrange</code><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.lagrange" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.lagrange_prox">
<code class="sig-name descname">lagrange_prox</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">lipschitz=1</em>, <em class="sig-param">lagrange=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.lagrange_prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique minimizer</p>
<div class="math notranslate nohighlight">
\[{B}^{\lambda}(\theta) =
\text{argmin}_{B \in \mathbb{R}^{{n \times p}}} 
\frac{L}{2}
\|\theta-B\|^2_2 + \lambda \|B\|_{\text{op}} \]</div>
<p>Above, <span class="math notranslate nohighlight">\(\lambda\)</span> is the Lagrange parameter and <span class="math notranslate nohighlight">\(L\)</span>
is the Lipschitz parameter and <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>arg</cite>.</p>
<p>If the argument <cite>lagrange</cite> is None and the atom is in lagrange mode,
<code class="docutils literal notranslate"><span class="pre">self.lagrange</span></code> is used as the lagrange parameter, else an exception
is raised.</p>
<p>The class atom’s lagrange_prox just returns the appropriate lagrange
parameter for use by the subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the proximal map.</p>
</div></blockquote>
<p><strong>lipschitz</strong> : <cite>float</cite></p>
<blockquote>
<div><p>Coefficient in front of the quadratic.</p>
</div></blockquote>
<p><strong>lagrange</strong> : <cite>float</cite> (optional)</p>
<blockquote>
<div><p>Lagrange factor in front of the seminorm. 
Defaults to <cite>self.lagrange</cite>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.latexify">
<code class="sig-name descname">latexify</code><span class="sig-paren">(</span><em class="sig-param">var=None</em>, <em class="sig-param">idx=''</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.latexify" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a LaTeX representation of an object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">latexify</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\gamma&#39;</span><span class="p">)</span> 
<span class="go">&#39;\\lambda_{} \\|\\gamma\\|_1&#39;</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>var</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Argument of the functions</p>
</div></blockquote>
<p><strong>idx</strong> : <cite>string</cite></p>
<blockquote>
<div><p>Optional subscript index.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>L</strong> : <cite>string</cite></p>
<blockquote>
<div><p>A LaTeX representation of the atom.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.linear">
<em class="property">classmethod </em><code class="sig-name descname">linear</code><span class="sig-paren">(</span><em class="sig-param">linear_operator</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em>, <em class="sig-param">offset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.linear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.linear_transform">
<em class="property">property </em><code class="sig-name descname">linear_transform</code><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.linear_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The linear transform applied before a penalty is computed. Defaults to regreg.affine.identity</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">regreg.api</span> <span class="k">import</span> <span class="n">l1norm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">l1norm</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">penalty</span><span class="o">.</span><span class="n">linear_transform</span><span class="p">)</span>
<span class="go">&lt;class &#39;regreg.affine.identity&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.nonsmooth_objective">
<code class="sig-name descname">nonsmooth_objective</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.nonsmooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The nonsmooth objective function of the atom.
Includes <cite>self.quadratic.objective(arg)</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">nonsmooth_objective</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">42</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>Argument of the seminorm.</p>
</div></blockquote>
<p><strong>check_feasibility</strong> : <cite>bool</cite></p>
<blockquote>
<div><p>If <cite>True</cite>, then return <cite>np.inf</cite> if appropriate.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> : <cite>np.float</cite></p>
<blockquote>
<div><p>The seminorm of <cite>arg</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.objective">
<code class="sig-name descname">objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.objective" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.affine.factored_matrix.operator_norm.objective_template">
<code class="sig-name descname">objective_template</code><em class="property"> = '\\|%(var)s\\|_{\\text{op}}'</em><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.objective_template" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.affine.factored_matrix.operator_norm.objective_vars">
<code class="sig-name descname">objective_vars</code><em class="property"> = {'dualnormklass': 'nuclear_norm', 'initargs': '(5,4)', 'linear': 'D', 'normklass': 'operator_norm', 'offset': '\\alpha', 'shape': '{n \\times p}', 'var': 'B'}</em><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.objective_vars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.offset">
<em class="property">property </em><code class="sig-name descname">offset</code><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.affine.factored_matrix.operator_norm.prox_tol">
<code class="sig-name descname">prox_tol</code><em class="property"> = 1e-05</em><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.prox_tol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>The proximal operator. If the atom is in
Lagrange mode, this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\lambda}(\theta) = \text{argmin}_{B \in
\mathbb{R}^{{n \times p}}} \frac{L}{2} \|\theta-B\|^2_2
+ \lambda h(B-\alpha) + \langle B, \eta \rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is <cite>self.offset</cite>,
<span class="math notranslate nohighlight">\(\eta\)</span> is <cite>quadratic.linear_term</cite>, <span class="math notranslate nohighlight">\(\theta\)</span> is <cite>quadratic.center</cite> and</p>
<div class="math notranslate nohighlight">
\[h(B) = \|B\|_{\text{op}}\]</div>
<p>If the atom is in bound mode, then this has the form</p>
<div class="math notranslate nohighlight">
\[B^{\delta}(\theta) = \text{argmin}_{B \in \mathbb{R}^{{n \times p}}} \frac{L}{2}
\|\theta-B\|^2_2 + \langle B, \eta \rangle \  \text{s.t.} \   
h(B - \alpha) \leq \delta\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">l1norm</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lagrange</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">identity_quadratic</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> 
<span class="go">array([ 1.6666..., -2.6666..., -0.        ,  0.        ])</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>quadratic</strong> : <cite>regreg.identity_quadratic.identity_quadratic</cite></p>
<blockquote>
<div><p>A quadratic added to the atom before minimizing.</p>
</div></blockquote>
<p><strong>prox_control</strong> : <cite>[None, dict]</cite></p>
<blockquote>
<div><p>This argument is ignored for seminorms, but otherwise
is passed to <cite>regreg.algorithms.FISTA</cite> if the atom
needs to be solved iteratively.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Z</strong> : <cite>np.ndarray(np.float)</cite></p>
<blockquote>
<div><p>The proximal map of the implied center of <cite>quadratic</cite>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.proximal_optimum">
<code class="sig-name descname">proximal_optimum</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.proximal_optimum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.proximal_step">
<code class="sig-name descname">proximal_step</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em>, <em class="sig-param">prox_control=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.proximal_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the proximal optimization</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>prox_control: [None, dict]</strong></p>
<blockquote>
<div><p>If not None, then a dictionary of parameters for the prox procedure</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.quadratic">
<em class="property">property </em><code class="sig-name descname">quadratic</code><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Quadratic part of the object, instance of <cite>regreg.identity_quadratic.identity_quadratic</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.seminorm">
<code class="sig-name descname">seminorm</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">check_feasibility=False</em>, <em class="sig-param">lagrange=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.seminorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math notranslate nohighlight">\(\lambda \cdot \|B\|_{\text{op}}\)</span>, where
<span class="math notranslate nohighlight">\(\lambda\)</span> is <cite>lagrange</cite>. If <cite>check_feasibility</cite>
is <cite>True</cite>, and seminorm is unbounded, will return <cite>np.inf</cite>
if appropriate.</p>
<p>The class seminorm’s seminorm just returns the appropriate lagrange
parameter for use by the subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.set_bound">
<code class="sig-name descname">set_bound</code><span class="sig-paren">(</span><em class="sig-param">bound</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.set_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the bound property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">operator_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">bound</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">operator_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">2.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in lagrange mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.set_lagrange">
<code class="sig-name descname">set_lagrange</code><span class="sig-paren">(</span><em class="sig-param">lagrange</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.set_lagrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Set method of the lagrange property.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">operator_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lagrange</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">3.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penalty</span><span class="o">.</span><span class="n">lagrange</span>
<span class="go">2.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">operator_norm</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraint</span><span class="o">.</span><span class="n">lagrange</span> <span class="o">=</span> <span class="mf">3.4</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">atom is in bound mode</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.set_offset">
<code class="sig-name descname">set_offset</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.set_offset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.set_quadratic">
<code class="sig-name descname">set_quadratic</code><span class="sig-paren">(</span><em class="sig-param">quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.set_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the quadratic part of the composite.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.shift">
<em class="property">classmethod </em><code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">offset</em>, <em class="sig-param">lagrange=None</em>, <em class="sig-param">diag=False</em>, <em class="sig-param">bound=None</em>, <em class="sig-param">quadratic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.shift" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.smooth_objective">
<code class="sig-name descname">smooth_objective</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">mode='both'</em>, <em class="sig-param">check_feasibility=False</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.smooth_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The zero function.</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.smoothed">
<code class="sig-name descname">smoothed</code><span class="sig-paren">(</span><em class="sig-param">smoothing_quadratic</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.smoothed" title="Permalink to this definition">¶</a></dt>
<dd><p>Add quadratic smoothing term</p>
</dd></dl>

<dl class="method">
<dt id="regreg.affine.factored_matrix.operator_norm.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">quadratic=None</em>, <em class="sig-param">return_optimum=False</em>, <em class="sig-param">**fit_args</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.affine.factored_matrix.operator_norm.svd_tol">
<code class="sig-name descname">svd_tol</code><em class="property"> = 0.0001</em><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.svd_tol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="regreg.affine.factored_matrix.operator_norm.tol">
<code class="sig-name descname">tol</code><em class="property"> = 1e-05</em><a class="headerlink" href="#regreg.affine.factored_matrix.operator_norm.tol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="regreg.affine.factored_matrix.compute_iterative_svd">
<code class="sig-prename descclassname">regreg.affine.factored_matrix.</code><code class="sig-name descname">compute_iterative_svd</code><span class="sig-paren">(</span><em class="sig-param">transform</em>, <em class="sig-param">initial_rank=None</em>, <em class="sig-param">warm_start=None</em>, <em class="sig-param">min_singular=1e-16</em>, <em class="sig-param">tol=1e-05</em>, <em class="sig-param">debug=False</em>, <em class="sig-param">stopping_rule=None</em>, <em class="sig-param">padding=5</em>, <em class="sig-param">update_rank=&lt;function &lt;lambda&gt;&gt;</em>, <em class="sig-param">max_rank=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.compute_iterative_svd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the SVD of a matrix using partial_svd.</p>
<p>If no initial rank is given, it assumes a rank of size min(n,p) / 10.</p>
<p>Iteratively calls <a class="reference internal" href="#regreg.affine.factored_matrix.partial_svd" title="regreg.affine.factored_matrix.partial_svd"><code class="xref py py-func docutils literal notranslate"><span class="pre">partial_svd()</span></code></a> until the <cite>singular_values</cite> are small
enough.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>transform</strong> : [linear_transform, ndarray]</p>
<blockquote>
<div><p>Linear_transform whose SVD is computed. If an
ndarray, it is first cast with <code class="xref py py-func docutils literal notranslate"><span class="pre">astransform()</span></code></p>
</div></blockquote>
<p><strong>initial_rank</strong> : None or int, optional</p>
<blockquote>
<div><p>A guess at the rank of the matrix.</p>
</div></blockquote>
<p><strong>warm_start</strong> : np.ndarray(np.float), optional</p>
<blockquote>
<div><p>A guess at the left singular vectors of the matrix.
For fat matrices, these should be right singular vectors,
while for tall matrices these should be left singular vectors.</p>
</div></blockquote>
<p><strong>min_singular</strong> : np.float, optional</p>
<blockquote>
<div><p>Stop when the singular value has this relative tolerance.</p>
</div></blockquote>
<p><strong>tol: np.float, optional</strong></p>
<blockquote>
<div><p>Tolerance at which the norm of the singular values are deemed
to have converged.</p>
</div></blockquote>
<p><strong>debug: bool, optional</strong></p>
<blockquote>
<div><p>Print debugging statements.</p>
</div></blockquote>
<p><strong>stopping_rule</strong> : None or callable, optional</p>
<blockquote>
<div><p>Function of the singular values <code class="docutils literal notranslate"><span class="pre">D</span></code>, returning True | False,  used to
determine whether to stop.  Continue while <code class="docutils literal notranslate"><span class="pre">stopping_rule(D)</span> <span class="pre">==</span>
<span class="pre">False</span></code>, or when <cite>stopping_rule</cite> is None.</p>
</div></blockquote>
<p><strong>padding</strong> : int, optional</p>
<blockquote>
<div><p>How many more singular vectors are found.</p>
</div></blockquote>
<p><strong>update_rank</strong> : callable, optional</p>
<blockquote>
<div><p>A rule to update rank, defaults to doubling the rank.</p>
</div></blockquote>
<p><strong>max_rank</strong> : None or int, optional</p>
<blockquote>
<div><p>Largest rank considered. Defaults to 2 * min(transform.output_shape[0], 
transform.input_shape[0]). An exception is raised if algorithm exceeds
given value.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>U, D, VT, Ufull</strong> : np.ndarray(np.float)</p>
<blockquote>
<div><p>An SVD of the transform. Ufull is the full set of left singular vectors
found.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">compute_iterative_svd</span><span class="p">(</span><span class="n">X</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1.e-6</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">VT</span><span class="p">,</span> <span class="n">VT</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1.e-6</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="regreg.affine.factored_matrix.partial_svd">
<code class="sig-prename descclassname">regreg.affine.factored_matrix.</code><code class="sig-name descname">partial_svd</code><span class="sig-paren">(</span><em class="sig-param">transform</em>, <em class="sig-param">rank=1</em>, <em class="sig-param">padding=5</em>, <em class="sig-param">max_its=1000</em>, <em class="sig-param">tol=1e-08</em>, <em class="sig-param">warm_start=None</em>, <em class="sig-param">return_full=False</em>, <em class="sig-param">debug=False</em>, <em class="sig-param">stopping_rule=None</em><span class="sig-paren">)</span><a class="headerlink" href="#regreg.affine.factored_matrix.partial_svd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute partial SVD of the linear transform <cite>transform</cite></p>
<p>Uses the Mazumder/Hastie algorithm in (TODO: CITE)</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>transform</strong> : [linear_transform, ndarray]</p>
<blockquote>
<div><p>Linear_transform whose SVD is computed. If an
ndarray, it is first cast with <code class="xref py py-func docutils literal notranslate"><span class="pre">astransform()</span></code></p>
</div></blockquote>
<p><strong>rank</strong> : int, optional</p>
<blockquote>
<div><p>What rank of SVD to compute.</p>
</div></blockquote>
<p><strong>padding</strong> : int, optional</p>
<blockquote>
<div><p>Compute a few further singular values / vectors. This results
in a better estimator of the rank of interest.</p>
</div></blockquote>
<p><strong>max_its</strong> : int, optional</p>
<blockquote>
<div><p>How many iterations of the full cycle to complete.</p>
</div></blockquote>
<p><strong>tol</strong> : np.float, optional</p>
<blockquote>
<div><p>Tolerance at which the norm of the singular values are deemed
to have converged.</p>
</div></blockquote>
<p><strong>warm_start</strong> : np.ndarray(np.float), optional</p>
<blockquote>
<div><p>A guess at the singular vectors of the matrix. 
For fat matrices, these should be right singular vectors,
while for tall matrices these should be left singular vectors.</p>
</div></blockquote>
<p><strong>return_full: bool, optional</strong></p>
<blockquote>
<div><p>Return a singular values / vectors from padding?</p>
</div></blockquote>
<p><strong>debug: bool, optional</strong></p>
<blockquote>
<div><p>Print debugging statements.</p>
</div></blockquote>
<p><strong>stopping_rule</strong> : callable</p>
<blockquote>
<div><p>Function of the singular values used to determine whether to stop.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>U, D, VT, Ufull</strong> : np.ndarray(np.float)</p>
<blockquote>
<div><p>An SVD up to <cite>rank</cite> of the transform.
Ufull is the full set of left singular vectors found.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">regreg.affine.factored_matrix</span> <span class="k">import</span> <span class="n">partial_svd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">partial_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">10</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1.e-4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">VT</span><span class="p">,</span> <span class="n">VT</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1.e-4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U_np</span><span class="p">,</span> <span class="n">D_np</span><span class="p">,</span> <span class="n">VT_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">U</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U_np</span><span class="o">.</span><span class="n">T</span><span class="p">[:</span><span class="mi">10</span><span class="p">],</span> <span class="n">U_np</span><span class="p">[:,:</span><span class="mi">10</span><span class="p">])))</span> <span class="o">&lt;</span> <span class="mf">1.e-4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">VT</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">VT</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">VT_np</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">VT_np</span><span class="p">[:</span><span class="mi">10</span><span class="p">])))</span> <span class="o">&lt;</span> <span class="mf">1.e-4</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="regreg.affine.fused_lasso.html" class="btn btn-neutral float-right" title="affine.fused_lasso" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="regreg.affine.html" class="btn btn-neutral float-left" title="affine" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2011-2017, B. Klingenberg &amp; J. Taylor
      <span class="lastupdated">
        Last updated on Sep 24, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>